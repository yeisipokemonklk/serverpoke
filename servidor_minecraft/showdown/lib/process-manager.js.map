{
  "version": 3,
  "sources": ["../../../lib/process-manager.ts"],
  "sourcesContent": ["/**\r\n * Process Manager\r\n * Pokemon Showdown - http://pokemonshowdown.com/\r\n *\r\n * This file abstract out multiprocess logic involved in several tasks.\r\n *\r\n * Child processes can be queried.\r\n *\r\n * @license MIT\r\n */\r\n\r\nimport * as child_process from 'child_process';\r\nimport * as cluster from 'cluster';\r\nimport * as path from 'path';\r\nimport * as Streams from './streams';\r\nimport {FS} from './fs';\r\n\r\ntype ChildProcess = child_process.ChildProcess;\r\ntype Worker = cluster.Worker;\r\n\r\nexport const processManagers: ProcessManager[] = [];\r\n\r\nexport function exec(args: string, execOptions?: child_process.ExecOptions): Promise<{stderr: string, stdout: string}>;\r\nexport function exec(\r\n\targs: [string, ...string[]], execOptions?: child_process.ExecFileOptions\r\n): Promise<{stderr: string, stdout: string}>;\r\nexport function exec(args: string | string[], execOptions?: AnyObject) {\r\n\tif (Array.isArray(args)) {\r\n\t\tconst cmd = args.shift();\r\n\t\tif (!cmd) throw new Error(`You must pass a command to ProcessManager.exec.`);\r\n\t\treturn new Promise<{stderr: string, stdout: string}>((resolve, reject) => {\r\n\t\t\tchild_process.execFile(cmd, args, execOptions, (err, stdout, stderr) => {\r\n\t\t\t\tif (err) reject(err);\r\n\t\t\t\tif (typeof stdout !== 'string') stdout = stdout.toString();\r\n\t\t\t\tif (typeof stderr !== 'string') stderr = stderr.toString();\r\n\t\t\t\tresolve({stdout, stderr});\r\n\t\t\t});\r\n\t\t});\r\n\t} else {\r\n\t\treturn new Promise<string>((resolve, reject) => {\r\n\t\t\tchild_process.exec(args, execOptions, (error, stdout, stderr) => {\r\n\t\t\t\tif (error) reject(error);\r\n\t\t\t\tif (typeof stdout !== 'string') stdout = stdout.toString();\r\n\t\t\t\tresolve(stdout);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}\r\n\r\nclass SubprocessStream extends Streams.ObjectReadWriteStream<string> {\r\n\tprocess: StreamProcessWrapper;\r\n\ttaskId: number;\r\n\tconstructor(process: StreamProcessWrapper, taskId: number) {\r\n\t\tsuper();\r\n\t\tthis.process = process;\r\n\t\tthis.taskId = taskId;\r\n\t\tthis.process.process.send(`${taskId}\\nNEW`);\r\n\t}\r\n\t_write(message: string) {\r\n\t\tif (!this.process.process.connected) {\r\n\t\t\tthis.pushError(new Error(`Process disconnected (possibly crashed?)`));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.process.process.send(`${this.taskId}\\nWRITE\\n${message}`);\r\n\t\t// responses are handled in ProcessWrapper\r\n\t}\r\n\t_writeEnd() {\r\n\t\tthis.process.process.send(`${this.taskId}\\nWRITEEND`);\r\n\t}\r\n\t_destroy() {\r\n\t\tif (!this.process.process.connected) return;\r\n\t\tthis.process.process.send(`${this.taskId}\\nDESTROY`);\r\n\t\tthis.process.deleteStream(this.taskId);\r\n\t\tthis.process = null!;\r\n\t}\r\n}\r\n\r\nclass RawSubprocessStream extends Streams.ObjectReadWriteStream<string> {\r\n\tprocess: RawProcessWrapper;\r\n\tconstructor(process: RawProcessWrapper) {\r\n\t\tsuper();\r\n\t\tthis.process = process;\r\n\t}\r\n\t_write(message: string) {\r\n\t\tif (!this.process.getProcess().connected) {\r\n\t\t\t// no error because the crash handler should already have shown an error, and\r\n\t\t\t// sometimes harmless messages are sent during cleanup\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.process.process.send(message);\r\n\t\t// responses are handled in ProcessWrapper\r\n\t}\r\n}\r\n\r\nexport interface ProcessWrapper {\r\n\tgetLoad: () => number;\r\n\tprocess: ChildProcess | Worker;\r\n\trelease: () => Promise<void>;\r\n\tgetProcess: () => ChildProcess;\r\n}\r\n\r\n/** Wraps the process object in the PARENT process. */\r\nexport class QueryProcessWrapper<T, U> implements ProcessWrapper {\r\n\tprocess: ChildProcess;\r\n\ttaskId: number;\r\n\tpendingTasks: Map<number, (resp: U) => void>;\r\n\tmessageCallback: ((message: string) => any) | null;\r\n\tpendingRelease: Promise<void> | null;\r\n\tresolveRelease: (() => void) | null;\r\n\tdebug?: string;\r\n\tfile: string;\r\n\r\n\tconstructor(file: string, messageCallback?: (message: string) => any) {\r\n\t\tthis.process = child_process.fork(file, [], {cwd: FS.ROOT_PATH});\r\n\t\tthis.taskId = 0;\r\n\t\tthis.file = file;\r\n\t\tthis.pendingTasks = new Map();\r\n\t\tthis.pendingRelease = null;\r\n\t\tthis.resolveRelease = null;\r\n\t\tthis.messageCallback = messageCallback || null;\r\n\r\n\t\tthis.process.on('message', (message: string) => {\r\n\t\t\tif (message.startsWith('THROW\\n')) {\r\n\t\t\t\tconst error = new Error();\r\n\t\t\t\terror.stack = message.slice(6);\r\n\t\t\t\tthrow error;\r\n\t\t\t}\r\n\r\n\t\t\tif (message.startsWith('DEBUG\\n')) {\r\n\t\t\t\tthis.debug = message.slice(6);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.messageCallback && message.startsWith(`CALLBACK\\n`)) {\r\n\t\t\t\tthis.messageCallback(message.slice(9));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst nlLoc = message.indexOf('\\n');\r\n\t\t\tif (nlLoc <= 0) throw new Error(`Invalid response ${message}`);\r\n\t\t\tconst taskId = parseInt(message.slice(0, nlLoc));\r\n\t\t\tconst resolve = this.pendingTasks.get(taskId);\r\n\t\t\tif (!resolve) throw new Error(`Invalid taskId ${message.slice(0, nlLoc)}`);\r\n\t\t\tthis.pendingTasks.delete(taskId);\r\n\t\t\tconst resp = this.safeJSON(message.slice(nlLoc + 1));\r\n\t\t\tresolve(resp);\r\n\r\n\t\t\tif (this.resolveRelease && !this.getLoad()) this.destroy();\r\n\t\t});\r\n\t}\r\n\tsafeJSON(obj: string): any {\r\n\t\t// special cases? undefined should strictly be fine\r\n\t\t// so let's just return it since we can't parse it\r\n\t\tif (obj === \"undefined\") {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn JSON.parse(obj);\r\n\t\t} catch (e: any) {\r\n\t\t\t// this is in the parent, so it should usually exist, but it's possible\r\n\t\t\t// it's also futureproofing in case other external modfules require this\r\n\t\t\t// we also specifically do not throw here because this json might be sensitive,\r\n\t\t\t// so we only want it to go to emails\r\n\t\t\tglobal.Monitor?.crashlog?.(e, `a ${path.basename(this.file)} process`, {result: obj});\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t}\r\n\r\n\tgetProcess() {\r\n\t\treturn this.process;\r\n\t}\r\n\r\n\tgetLoad() {\r\n\t\treturn this.pendingTasks.size;\r\n\t}\r\n\r\n\tquery(input: T): Promise<U> {\r\n\t\tthis.taskId++;\r\n\t\tconst taskId = this.taskId;\r\n\t\tthis.process.send(`${taskId}\\n${JSON.stringify(input)}`);\r\n\t\treturn new Promise(resolve => {\r\n\t\t\tthis.pendingTasks.set(taskId, resolve);\r\n\t\t});\r\n\t}\r\n\r\n\trelease(): Promise<void> {\r\n\t\tif (this.pendingRelease) return this.pendingRelease;\r\n\t\tif (!this.getLoad()) {\r\n\t\t\tthis.destroy();\r\n\t\t} else {\r\n\t\t\tthis.pendingRelease = new Promise(resolve => {\r\n\t\t\t\tthis.resolveRelease = resolve;\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this.pendingRelease as Promise<void>;\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\tif (this.pendingRelease && !this.resolveRelease) {\r\n\t\t\t// already destroyed\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.process.disconnect();\r\n\t\tfor (const resolver of this.pendingTasks.values()) {\r\n\t\t\t// maybe we should track reject functions too...\r\n\t\t\tresolver('' as any);\r\n\t\t}\r\n\t\tthis.pendingTasks.clear();\r\n\t\tif (this.resolveRelease) {\r\n\t\t\tthis.resolveRelease();\r\n\t\t\tthis.resolveRelease = null;\r\n\t\t} else if (!this.pendingRelease) {\r\n\t\t\tthis.pendingRelease = Promise.resolve();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/** Wraps the process object in the PARENT process. */\r\nexport class StreamProcessWrapper implements ProcessWrapper {\r\n\tprocess: ChildProcess;\r\n\ttaskId = 0;\r\n\tactiveStreams = new Map<number, SubprocessStream>();\r\n\tpendingRelease: Promise<void> | null = null;\r\n\tresolveRelease: (() => void) | null = null;\r\n\tdebug?: string;\r\n\r\n\tsetDebug(message: string) {\r\n\t\tthis.debug = (this.debug || '').slice(-32768) + '\\n=====\\n' + message;\r\n\t}\r\n\tmessageCallback?: (message: string) => any;\r\n\r\n\tconstructor(file: string, messageCallback?: (message: string) => any) {\r\n\t\tthis.process = child_process.fork(file, [], {cwd: FS.ROOT_PATH});\r\n\t\tthis.messageCallback = messageCallback;\r\n\r\n\t\tthis.process.on('message', (message: string) => {\r\n\t\t\tif (message.startsWith('THROW\\n')) {\r\n\t\t\t\tconst error = new Error();\r\n\t\t\t\terror.stack = message.slice(6);\r\n\t\t\t\tthrow error;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.messageCallback && message.startsWith(`CALLBACK\\n`)) {\r\n\t\t\t\tthis.messageCallback(message.slice(9));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (message.startsWith('DEBUG\\n')) {\r\n\t\t\t\tthis.setDebug(message.slice(6));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet nlLoc = message.indexOf('\\n');\r\n\t\t\tif (nlLoc <= 0) throw new Error(`Invalid response ${message}`);\r\n\t\t\tconst taskId = parseInt(message.slice(0, nlLoc));\r\n\t\t\tconst stream = this.activeStreams.get(taskId);\r\n\t\t\tif (!stream) return; // stream already destroyed\r\n\r\n\t\t\tmessage = message.slice(nlLoc + 1);\r\n\t\t\tnlLoc = message.indexOf('\\n');\r\n\t\t\tif (nlLoc < 0) nlLoc = message.length;\r\n\t\t\tconst messageType = message.slice(0, nlLoc);\r\n\t\t\tmessage = message.slice(nlLoc + 1);\r\n\r\n\t\t\tif (messageType === 'END') {\r\n\t\t\t\tstream.pushEnd();\r\n\t\t\t\tthis.deleteStream(taskId);\r\n\t\t\t\treturn;\r\n\t\t\t} else if (messageType === 'PUSH') {\r\n\t\t\t\tstream.push(message);\r\n\t\t\t} else if (messageType === 'THROW') {\r\n\t\t\t\tconst error = new Error();\r\n\t\t\t\terror.stack = message;\r\n\t\t\t\tstream.pushError(error, true);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(`Unrecognized messageType ${messageType}`);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tgetLoad() {\r\n\t\treturn this.activeStreams.size;\r\n\t}\r\n\r\n\tgetProcess() {\r\n\t\treturn this.process;\r\n\t}\r\n\r\n\tdeleteStream(taskId: number) {\r\n\t\tthis.activeStreams.delete(taskId);\r\n\t\t// try to release\r\n\t\tif (this.resolveRelease && !this.getLoad()) void this.destroy();\r\n\t}\r\n\r\n\tcreateStream(): SubprocessStream {\r\n\t\tthis.taskId++;\r\n\t\tconst taskId = this.taskId;\r\n\t\tconst stream = new SubprocessStream(this, taskId);\r\n\t\tthis.activeStreams.set(taskId, stream);\r\n\t\treturn stream;\r\n\t}\r\n\r\n\trelease(): Promise<void> {\r\n\t\tif (this.pendingRelease) return this.pendingRelease;\r\n\t\tif (!this.getLoad()) {\r\n\t\t\tvoid this.destroy();\r\n\t\t} else {\r\n\t\t\tthis.pendingRelease = new Promise(resolve => {\r\n\t\t\t\tthis.resolveRelease = resolve;\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this.pendingRelease as Promise<void>;\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\tif (this.pendingRelease && !this.resolveRelease) {\r\n\t\t\t// already destroyed\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.process.disconnect();\r\n\t\tconst destroyed = [];\r\n\t\tfor (const stream of this.activeStreams.values()) {\r\n\t\t\tdestroyed.push(stream.destroy());\r\n\t\t}\r\n\t\tthis.activeStreams.clear();\r\n\t\tif (this.resolveRelease) {\r\n\t\t\tthis.resolveRelease();\r\n\t\t\tthis.resolveRelease = null;\r\n\t\t} else if (!this.pendingRelease) {\r\n\t\t\tthis.pendingRelease = Promise.resolve();\r\n\t\t}\r\n\t\treturn Promise.all(destroyed);\r\n\t}\r\n}\r\n\r\n/**\r\n * A container for a RawProcessManager stream. This is usually the\r\n * RawProcessWrapper, but it can also be a fake RawProcessWrapper if the PM is\r\n * told to spawn 0 worker processes.\r\n */\r\nexport class StreamWorker {\r\n\tload = 0;\r\n\tworkerid = 0;\r\n\tstream: Streams.ObjectReadWriteStream<string>;\r\n\tconstructor(stream: Streams.ObjectReadWriteStream<string>) {\r\n\t\tthis.stream = stream;\r\n\t}\r\n}\r\n\r\n/** Wraps the process object in the PARENT process. */\r\nexport class RawProcessWrapper implements ProcessWrapper, StreamWorker {\r\n\tprocess: ChildProcess & {process: undefined} | Worker;\r\n\ttaskId = 0;\r\n\tstream: RawSubprocessStream;\r\n\tpendingRelease: Promise<void> | null = null;\r\n\tresolveRelease: (() => void) | null = null;\r\n\tdebug?: string;\r\n\tworkerid = 0;\r\n\r\n\t/** Not managed by RawProcessWrapper itself */\r\n\tload = 0;\r\n\r\n\tsetDebug(message: string) {\r\n\t\tthis.debug = (this.debug || '').slice(-32768) + '\\n=====\\n' + message;\r\n\t}\r\n\r\n\tconstructor(file: string, isCluster?: boolean, env?: AnyObject) {\r\n\t\tif (isCluster) {\r\n\t\t\tthis.process = cluster.fork(env);\r\n\t\t\tthis.workerid = this.process.id;\r\n\t\t} else {\r\n\t\t\tthis.process = child_process.fork(file, [], {cwd: FS.ROOT_PATH, env}) as any;\r\n\t\t}\r\n\r\n\t\tthis.process.on('message', (message: string) => {\r\n\t\t\tthis.stream.push(message);\r\n\t\t});\r\n\r\n\t\tthis.stream = new RawSubprocessStream(this);\r\n\t}\r\n\r\n\tgetLoad() {\r\n\t\treturn this.load;\r\n\t}\r\n\tgetProcess() {\r\n\t\treturn this.process.process ? this.process.process : this.process;\r\n\t}\r\n\r\n\trelease(): Promise<void> {\r\n\t\tif (this.pendingRelease) return this.pendingRelease;\r\n\t\tif (!this.getLoad()) {\r\n\t\t\tvoid this.destroy();\r\n\t\t} else {\r\n\t\t\tthis.pendingRelease = new Promise(resolve => {\r\n\t\t\t\tthis.resolveRelease = resolve;\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this.pendingRelease as Promise<void>;\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\tif (this.pendingRelease && !this.resolveRelease) {\r\n\t\t\t// already destroyed\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvoid this.stream.destroy();\r\n\t\tthis.process.disconnect();\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\n/**\r\n * A ProcessManager wraps a query function: A function that takes a\r\n * string and returns a string or Promise<string>.\r\n */\r\nexport abstract class ProcessManager<T extends ProcessWrapper = ProcessWrapper> {\r\n\tstatic disabled = false;\r\n\tprocesses: T[] = [];\r\n\treleasingProcesses: T[] = [];\r\n\tcrashedProcesses: T[] = [];\r\n\treadonly filename: string;\r\n\treadonly basename: string;\r\n\treadonly isParentProcess: boolean;\r\n\tcrashTime = 0;\r\n\tcrashRespawnCount = 0;\r\n\r\n\tconstructor(module: NodeJS.Module) {\r\n\t\tthis.filename = module.filename;\r\n\t\tthis.basename = path.basename(module.filename);\r\n\t\tthis.isParentProcess = (process.mainModule !== module || !process.send);\r\n\r\n\t\tthis.listen();\r\n\t}\r\n\tacquire() {\r\n\t\tif (!this.processes.length) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tlet lowestLoad = this.processes[0];\r\n\t\tfor (const process of this.processes) {\r\n\t\t\tif (process.getLoad() < lowestLoad.getLoad()) {\r\n\t\t\t\tlowestLoad = process;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn lowestLoad;\r\n\t}\r\n\treleaseCrashed(process: T) {\r\n\t\tconst index = this.processes.indexOf(process);\r\n\r\n\t\t// The process was shut down sanely, not crashed\r\n\t\tif (index < 0) return;\r\n\r\n\t\tthis.processes.splice(index, 1);\r\n\r\n\t\tthis.destroyProcess(process);\r\n\t\tvoid process.release().then(() => {\r\n\t\t\tconst releasingIndex = this.releasingProcesses.indexOf(process);\r\n\t\t\tif (releasingIndex >= 0) {\r\n\t\t\t\tthis.releasingProcesses.splice(releasingIndex, 1);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tconst now = Date.now();\r\n\t\tif (this.crashTime && now - this.crashTime > 30 * 60 * 1000) {\r\n\t\t\tthis.crashTime = 0;\r\n\t\t\tthis.crashRespawnCount = 0;\r\n\t\t}\r\n\t\tif (!this.crashTime) this.crashTime = now;\r\n\t\tthis.crashRespawnCount += 1;\r\n\t\t// Notify any global crash logger\r\n\t\tvoid Promise.reject(\r\n\t\t\tnew Error(`Process ${this.basename} ${process.getProcess().pid} crashed and had to be restarted`)\r\n\t\t);\r\n\t\tthis.releasingProcesses.push(process);\r\n\t\tthis.crashedProcesses.push(process);\r\n\r\n\t\t// only respawn processes if there have been fewer than 5 crashes in 30 minutes\r\n\t\tif (this.crashRespawnCount <= 5) {\r\n\t\t\tthis.spawn(this.processes.length + 1);\r\n\t\t}\r\n\t}\r\n\tunspawn() {\r\n\t\treturn Promise.all([...this.processes].map(\r\n\t\t\tprocess => this.unspawnOne(process)\r\n\t\t));\r\n\t}\r\n\tasync unspawnOne(process: T | null) {\r\n\t\tif (!process) return;\r\n\t\tthis.destroyProcess(process);\r\n\t\tconst processIndex = this.processes.indexOf(process);\r\n\t\tif (processIndex < 0) throw new Error('Process inactive');\r\n\t\tthis.processes.splice(this.processes.indexOf(process), 1);\r\n\t\tthis.releasingProcesses.push(process);\r\n\r\n\t\tawait process.release();\r\n\r\n\t\tconst index = this.releasingProcesses.indexOf(process);\r\n\t\tif (index < 0) return; // can happen if process crashed while releasing\r\n\t\tthis.releasingProcesses.splice(index, 1);\r\n\t}\r\n\tspawn(count = 1, force?: boolean) {\r\n\t\tif (!this.isParentProcess) return;\r\n\t\tif (ProcessManager.disabled && !force) return;\r\n\t\tconst spawnCount = count - this.processes.length;\r\n\t\tfor (let i = 0; i < spawnCount; i++) {\r\n\t\t\tthis.spawnOne(force);\r\n\t\t}\r\n\t}\r\n\tspawnOne(force?: boolean) {\r\n\t\tif (!this.isParentProcess) throw new Error('Must use in parent process');\r\n\t\tif (ProcessManager.disabled && !force) return null;\r\n\t\tconst process = this.createProcess();\r\n\t\tprocess.process.on('disconnect', () => this.releaseCrashed(process));\r\n\t\tthis.processes.push(process);\r\n\t\treturn process;\r\n\t}\r\n\trespawn(count: number | null = null) {\r\n\t\tif (count === null) count = this.processes.length;\r\n\t\tconst unspawned = this.unspawn();\r\n\t\tthis.spawn(count);\r\n\t\treturn unspawned;\r\n\t}\r\n\tabstract listen(): void;\r\n\tabstract createProcess(...args: any): T;\r\n\tdestroyProcess(process: T) {}\r\n\tdestroy() {\r\n\t\tconst index = processManagers.indexOf(this);\r\n\t\tif (index >= 0) processManagers.splice(index, 1);\r\n\t\treturn this.unspawn();\r\n\t}\r\n}\r\n\r\nexport class QueryProcessManager<T = string, U = string> extends ProcessManager<QueryProcessWrapper<T, U>> {\r\n\t_query: (input: T) => U | Promise<U>;\r\n\tmessageCallback?: (message: string) => any;\r\n\ttimeout: number;\r\n\r\n\t/**\r\n\t * @param timeout The number of milliseconds to wait before terminating a query. Defaults to 900000 ms (15 minutes).\r\n\t */\r\n\tconstructor(\r\n\t\tmodule: NodeJS.Module, query: (input: T) => U | Promise<U>,\r\n\t\ttimeout = 15 * 60 * 1000, debugCallback?: (message: string) => any\r\n\t) {\r\n\t\tsuper(module);\r\n\t\tthis._query = query;\r\n\t\tthis.timeout = timeout;\r\n\t\tthis.messageCallback = debugCallback;\r\n\r\n\t\tprocessManagers.push(this);\r\n\t}\r\n\tasync query(input: T, process = this.acquire()) {\r\n\t\tif (!process) return this._query(input);\r\n\r\n\t\tconst timeout = setTimeout(() => {\r\n\t\t\tconst debugInfo = process.debug || \"No debug information found.\";\r\n\t\t\tprocess.destroy();\r\n\t\t\tthis.spawnOne();\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`A query originating in ${this.basename} took too long to complete; the process has been respawned.\\n${debugInfo}`\r\n\t\t\t);\r\n\t\t}, this.timeout);\r\n\r\n\t\tconst result = await process.query(input);\r\n\r\n\t\tclearTimeout(timeout);\r\n\t\treturn result;\r\n\t}\r\n\tqueryTemporaryProcess(input: T, force?: boolean) {\r\n\t\tconst process = this.spawnOne(force);\r\n\t\tconst result = this.query(input, process);\r\n\t\tvoid this.unspawnOne(process);\r\n\t\treturn result;\r\n\t}\r\n\tcreateProcess() {\r\n\t\treturn new QueryProcessWrapper<T, U>(this.filename, this.messageCallback);\r\n\t}\r\n\tlisten() {\r\n\t\tif (this.isParentProcess) return;\r\n\t\t// child process\r\n\t\tprocess.on('message', (message: string) => {\r\n\t\t\tconst nlLoc = message.indexOf('\\n');\r\n\t\t\tif (nlLoc <= 0) throw new Error(`Invalid response ${message}`);\r\n\t\t\tconst taskId = message.slice(0, nlLoc);\r\n\t\t\tmessage = message.slice(nlLoc + 1);\r\n\r\n\t\t\tif (taskId.startsWith('EVAL')) {\r\n\t\t\t\t// eslint-disable-next-line no-eval\r\n\t\t\t\tprocess.send!(`${taskId}\\n` + eval(message));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvoid Promise.resolve(this._query(JSON.parse(message))).then(\r\n\t\t\t\tresponse => process.send!(`${taskId}\\n${JSON.stringify(response)}`)\r\n\t\t\t);\r\n\t\t});\r\n\t\tprocess.on('disconnect', () => {\r\n\t\t\tprocess.exit();\r\n\t\t});\r\n\t}\r\n}\r\n\r\nexport class StreamProcessManager extends ProcessManager<StreamProcessWrapper> {\r\n\t/* taskid: stream used only in child process */\r\n\tactiveStreams: Map<string, Streams.ObjectReadWriteStream<string>>;\r\n\t_createStream: () => Streams.ObjectReadWriteStream<string>;\r\n\tmessageCallback?: (message: string) => any;\r\n\r\n\tconstructor(\r\n\t\tmodule: NodeJS.Module,\r\n\t\tcreateStream: () => Streams.ObjectReadWriteStream<string>,\r\n\t\tmessageCallback?: (message: string) => any\r\n\t) {\r\n\t\tsuper(module);\r\n\t\tthis.activeStreams = new Map();\r\n\t\tthis._createStream = createStream;\r\n\t\tthis.messageCallback = messageCallback;\r\n\r\n\t\tprocessManagers.push(this);\r\n\t}\r\n\tcreateStream() {\r\n\t\tconst process = this.acquire();\r\n\t\tif (!process) return this._createStream();\r\n\t\treturn process.createStream();\r\n\t}\r\n\tcreateProcess() {\r\n\t\treturn new StreamProcessWrapper(this.filename, this.messageCallback);\r\n\t}\r\n\tasync pipeStream(taskId: string, stream: Streams.ObjectReadStream<string>) {\r\n\t\tlet done = false;\r\n\t\twhile (!done) {\r\n\t\t\ttry {\r\n\t\t\t\tlet value;\r\n\t\t\t\t({value, done} = await stream.next());\r\n\t\t\t\tprocess.send!(`${taskId}\\nPUSH\\n${value}`);\r\n\t\t\t} catch (err: any) {\r\n\t\t\t\tprocess.send!(`${taskId}\\nTHROW\\n${err.stack}`);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this.activeStreams.has(taskId)) {\r\n\t\t\t// stream.destroy() was called, don't send an END message\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tprocess.send!(`${taskId}\\nEND`);\r\n\t\tthis.activeStreams.delete(taskId);\r\n\t}\r\n\tlisten() {\r\n\t\tif (this.isParentProcess) return;\r\n\t\t// child process\r\n\t\tprocess.on('message', (message: string) => {\r\n\t\t\tlet nlLoc = message.indexOf('\\n');\r\n\t\t\tif (nlLoc <= 0) throw new Error(`Invalid request ${message}`);\r\n\t\t\tconst taskId = message.slice(0, nlLoc);\r\n\t\t\tconst stream = this.activeStreams.get(taskId);\r\n\r\n\t\t\tmessage = message.slice(nlLoc + 1);\r\n\t\t\tnlLoc = message.indexOf('\\n');\r\n\t\t\tif (nlLoc < 0) nlLoc = message.length;\r\n\t\t\tconst messageType = message.slice(0, nlLoc);\r\n\t\t\tmessage = message.slice(nlLoc + 1);\r\n\r\n\t\t\tif (taskId.startsWith('EVAL')) {\r\n\t\t\t\t// eslint-disable-next-line no-eval\r\n\t\t\t\tprocess.send!(`${taskId}\\n` + eval(message));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (messageType === 'NEW') {\r\n\t\t\t\tif (stream) throw new Error(`NEW: taskId ${taskId} already exists`);\r\n\t\t\t\tconst newStream = this._createStream();\r\n\t\t\t\tthis.activeStreams.set(taskId, newStream);\r\n\t\t\t\tvoid this.pipeStream(taskId, newStream);\r\n\t\t\t} else if (messageType === 'DESTROY') {\r\n\t\t\t\tif (!stream) throw new Error(`DESTROY: Invalid taskId ${taskId}`);\r\n\t\t\t\tvoid stream.destroy();\r\n\t\t\t\tthis.activeStreams.delete(taskId);\r\n\t\t\t} else if (messageType === 'WRITE') {\r\n\t\t\t\tif (!stream) throw new Error(`WRITE: Invalid taskId ${taskId}`);\r\n\t\t\t\tvoid stream.write(message);\r\n\t\t\t} else if (messageType === 'WRITEEND') {\r\n\t\t\t\tif (!stream) throw new Error(`WRITEEND: Invalid taskId ${taskId}`);\r\n\t\t\t\tvoid stream.writeEnd();\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(`Unrecognized messageType ${messageType}`);\r\n\t\t\t}\r\n\t\t});\r\n\t\tprocess.on('disconnect', () => {\r\n\t\t\tprocess.exit();\r\n\t\t});\r\n\t}\r\n}\r\n\r\nexport class RawProcessManager extends ProcessManager<RawProcessWrapper> {\r\n\t/** full list of processes - parent process only */\r\n\tworkers: StreamWorker[] = [];\r\n\t/** if spawning 0 worker processes, the worker is instead stored here in the parent process */\r\n\tmasterWorker: StreamWorker | null = null;\r\n\t/** stream used only in the child process */\r\n\tactiveStream: Streams.ObjectReadWriteStream<string> | null = null;\r\n\tisCluster: boolean;\r\n\tspawnSubscription: ((worker: StreamWorker) => void) | null = null;\r\n\tunspawnSubscription: ((worker: StreamWorker) => void) | null = null;\r\n\t_setupChild: () => Streams.ObjectReadWriteStream<string>;\r\n\t/** worker ID of cluster worker - cluster child process only (0 otherwise) */\r\n\treadonly workerid = cluster.worker?.id || 0;\r\n\tenv: AnyObject | undefined;\r\n\r\n\tconstructor(options: {\r\n\t\tmodule: NodeJS.Module,\r\n\t\tsetupChild: () => Streams.ObjectReadWriteStream<string>,\r\n\t\tisCluster?: boolean,\r\n\t\tenv?: AnyObject,\r\n\t}) {\r\n\t\tsuper(options.module);\r\n\t\tthis.isCluster = !!options.isCluster;\r\n\t\tthis._setupChild = options.setupChild;\r\n\t\tthis.env = options.env;\r\n\r\n\t\tif (this.isCluster && this.isParentProcess) {\r\n\t\t\tcluster.setupMaster({\r\n\t\t\t\texec: this.filename,\r\n\t\t\t\t// @ts-ignore TODO: update type definition\r\n\t\t\t\tcwd: FS.ROOT_PATH,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tprocessManagers.push(this);\r\n\t}\r\n\tsubscribeSpawn(callback: (worker: StreamWorker) => void) {\r\n\t\tthis.spawnSubscription = callback;\r\n\t}\r\n\tsubscribeUnspawn(callback: (worker: StreamWorker) => void) {\r\n\t\tthis.unspawnSubscription = callback;\r\n\t}\r\n\tspawn(count?: number) {\r\n\t\tsuper.spawn(count);\r\n\t\tif (!this.workers.length) {\r\n\t\t\tthis.masterWorker = new StreamWorker(this._setupChild());\r\n\t\t\tthis.workers.push(this.masterWorker);\r\n\t\t\tthis.spawnSubscription?.(this.masterWorker);\r\n\t\t}\r\n\t}\r\n\tcreateProcess() {\r\n\t\tconst process = new RawProcessWrapper(this.filename, this.isCluster, this.env);\r\n\t\tthis.workers.push(process);\r\n\t\tthis.spawnSubscription?.(process);\r\n\t\treturn process;\r\n\t}\r\n\tdestroyProcess(process: RawProcessWrapper) {\r\n\t\tconst index = this.workers.indexOf(process);\r\n\t\tif (index >= 0) this.workers.splice(index, 1);\r\n\r\n\t\tthis.unspawnSubscription?.(process);\r\n\t}\r\n\tasync pipeStream(stream: Streams.ObjectReadStream<string>) {\r\n\t\tlet done = false;\r\n\t\twhile (!done) {\r\n\t\t\ttry {\r\n\t\t\t\tlet value;\r\n\t\t\t\t({value, done} = await stream.next());\r\n\t\t\t\tprocess.send!(value);\r\n\t\t\t} catch (err: any) {\r\n\t\t\t\tprocess.send!(`THROW\\n${err.stack}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tlisten() {\r\n\t\tif (this.isParentProcess) return;\r\n\r\n\t\tsetImmediate(() => {\r\n\t\t\tthis.activeStream = this._setupChild();\r\n\t\t\tvoid this.pipeStream(this.activeStream);\r\n\t\t});\r\n\r\n\t\t// child process\r\n\t\tprocess.on('message', (message: string) => {\r\n\t\t\tvoid this.activeStream!.write(message);\r\n\t\t});\r\n\t\tprocess.on('disconnect', () => {\r\n\t\t\tprocess.exit();\r\n\t\t});\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["process", "taskId", "message", "nlLoc", "stream", "messageType", "module"]
}
