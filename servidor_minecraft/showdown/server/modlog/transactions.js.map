{
  "version": 3,
  "sources": ["../../../../server/modlog/transactions.ts"],
  "sourcesContent": ["/**\r\n * SQL transactions for the modlog.\r\n */\r\n\r\nimport type {TransactionEnvironment} from '../../lib/sql';\r\nimport type {TransactionArguments} from '.';\r\n\r\nexport const transactions = {\r\n\tinsertion: (args: TransactionArguments, env: TransactionEnvironment) => {\r\n\t\tconst modlogInsertion = env.statements.get(args.modlogInsertionStatement);\r\n\t\tconst altsInsertion = env.statements.get(args.altsInsertionStatement);\r\n\t\tif (!modlogInsertion) {\r\n\t\t\tthrow new Error(`Couldn't find prepared statement for provided value (args.modlogInsertionStatement=${args.modlogInsertionStatement}`);\r\n\t\t}\r\n\t\tif (!altsInsertion) {\r\n\t\t\tthrow new Error(`Couldn't find prepared statement for provided value (args.altsInsertionStatement=${args.altsInsertionStatement}`);\r\n\t\t}\r\n\r\n\t\tfor (const entry of args.entries) {\r\n\t\t\t// SQLite doesn't have a boolean type, so this is a workaround.\r\n\t\t\tentry.isGlobal = Number(entry.isGlobal) as any;\r\n\t\t\tconst result = modlogInsertion.run(entry);\r\n\t\t\tconst rowid = result.lastInsertRowid as number;\r\n\r\n\t\t\tfor (const alt of entry.alts || []) {\r\n\t\t\t\taltsInsertion.run(rowid, alt);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAOO,MAAM,eAAe;AAAA,EAC3B,WAAW,CAAC,MAA4B,QAAgC;AACvE,UAAM,kBAAkB,IAAI,WAAW,IAAI,KAAK,wBAAwB;AACxE,UAAM,gBAAgB,IAAI,WAAW,IAAI,KAAK,sBAAsB;AACpE,QAAI,CAAC,iBAAiB;AACrB,YAAM,IAAI,MAAM,sFAAsF,KAAK,0BAA0B;AAAA,IACtI;AACA,QAAI,CAAC,eAAe;AACnB,YAAM,IAAI,MAAM,oFAAoF,KAAK,wBAAwB;AAAA,IAClI;AAEA,eAAW,SAAS,KAAK,SAAS;AAEjC,YAAM,WAAW,OAAO,MAAM,QAAQ;AACtC,YAAM,SAAS,gBAAgB,IAAI,KAAK;AACxC,YAAM,QAAQ,OAAO;AAErB,iBAAW,OAAO,MAAM,QAAQ,CAAC,GAAG;AACnC,sBAAc,IAAI,OAAO,GAAG;AAAA,MAC7B;AAAA,IACD;AAAA,EACD;AACD;",
  "names": []
}
