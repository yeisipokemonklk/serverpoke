{
  "version": 3,
  "sources": ["../../../server/punishments.ts"],
  "sourcesContent": ["/**\r\n * Punishments\r\n * Pokemon Showdown - http://pokemonshowdown.com/\r\n *\r\n * Handles the punishing of users on PS.\r\n *\r\n * There are four types of global punishments on PS. Locks, bans, namelocks and rangelocks.\r\n * This file contains the lists of users that have been punished (both IPs and usernames),\r\n * as well as the functions that handle the execution of said punishments.\r\n *\r\n * @license MIT license\r\n */\r\n\r\nimport {FS, Utils} from '../lib';\r\nimport type {AddressRange} from './ip-tools';\r\n\r\nconst PUNISHMENT_FILE = 'config/punishments.tsv';\r\nconst ROOM_PUNISHMENT_FILE = 'config/room-punishments.tsv';\r\nconst SHAREDIPS_FILE = 'config/sharedips.tsv';\r\nconst SHAREDIPS_BLACKLIST_FILE = 'config/sharedips-blacklist.tsv';\r\nconst WHITELISTED_NAMES_FILE = 'config/name-whitelist.tsv';\r\n\r\nconst RANGELOCK_DURATION = 60 * 60 * 1000; // 1 hour\r\nconst LOCK_DURATION = 48 * 60 * 60 * 1000; // 48 hours\r\nconst GLOBALBAN_DURATION = 7 * 24 * 60 * 60 * 1000; // 1 week\r\nconst BATTLEBAN_DURATION = 48 * 60 * 60 * 1000; // 48 hours\r\nconst GROUPCHATBAN_DURATION = 7 * 24 * 60 * 60 * 1000; // 1 week\r\nconst MOBILE_PUNISHMENT_DURATIION = 6 * 60 * 60 * 1000; // 6 hours\r\n\r\nconst ROOMBAN_DURATION = 48 * 60 * 60 * 1000; // 48 hours\r\nconst BLACKLIST_DURATION = 365 * 24 * 60 * 60 * 1000; // 1 year\r\n\r\nconst USERID_REGEX = /^[a-z0-9]+$/;\r\nconst PUNISH_TRUSTED = false;\r\n\r\nconst PUNISHMENT_POINT_VALUES: {[k: string]: number} = {MUTE: 2, BLACKLIST: 3, ROOMBAN: 4};\r\nconst AUTOLOCK_POINT_THRESHOLD = 8;\r\n\r\nconst AUTOWEEKLOCK_THRESHOLD = 5; // number of global punishments to upgrade autolocks to weeklocks\r\nconst AUTOWEEKLOCK_DAYS_TO_SEARCH = 60;\r\n\r\n/** The longest amount of time any individual timeout will be set for. */\r\nconst MAX_PUNISHMENT_TIMER_LENGTH = 24 * 60 * 60 * 1000; // 24 hours\r\n\r\n/**\r\n * The number of users from a groupchat whose creator was banned from using groupchats\r\n * who may join a new groupchat before the GroupchatMonitor activates.\r\n */\r\nconst GROUPCHAT_PARTICIPANT_OVERLAP_THRESHOLD = 5;\r\n/**\r\n * The minimum amount of time that must pass between activations of the GroupchatMonitor.\r\n */\r\nconst GROUPCHAT_MONITOR_INTERVAL = 10 * 60 * 1000; // 10 minutes\r\n\r\nexport interface Punishment {\r\n\ttype: string;\r\n\tid: ID | PunishType;\r\n\texpireTime: number;\r\n\treason: string;\r\n\trest?: any[];\r\n}\r\n\r\n/**\r\n * Info on punishment types. Can be used for either room punishment types or global punishments\r\n * extended by plugins. The `desc` is the /alts display, and the `callback` is what to do if the user\r\n * _does_ have the punishment (can be used to add extra effects in lieu of something like a loginfilter.)\r\n * Rooms will be specified for room punishments, otherwise it's null for global punishments\r\n */\r\nexport interface PunishInfo {\r\n\tdesc: string;\r\n\tonActivate?: (user: User, punishment: Punishment, room: Room | null, isExactMatch: boolean) => void;\r\n\t/** For room punishments - should they count for punishmentmonitor? default to no. */\r\n\tactivatePunishMonitor?: boolean;\r\n}\r\n\r\ninterface PunishmentEntry {\r\n\tips: string[];\r\n\tuserids: ID[];\r\n\tpunishType: string;\r\n\texpireTime: number;\r\n\treason: string;\r\n\trest: any[];\r\n}\r\n\r\nclass PunishmentMap extends Map<string, Punishment[]> {\r\n\troomid?: RoomID;\r\n\tconstructor(roomid?: RoomID) {\r\n\t\tsuper();\r\n\t\tthis.roomid = roomid;\r\n\t}\r\n\tremoveExpiring(punishments: Punishment[]) {\r\n\t\tfor (const [i, punishment] of punishments.entries()) {\r\n\t\t\tif (Date.now() > punishment.expireTime) {\r\n\t\t\t\tpunishments.splice(i, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tget(k: string) {\r\n\t\tconst punishments = super.get(k);\r\n\t\tif (punishments) {\r\n\t\t\tthis.removeExpiring(punishments);\r\n\t\t\tif (punishments.length) return punishments;\r\n\t\t\tthis.delete(k);\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\thas(k: string) {\r\n\t\treturn !!this.get(k);\r\n\t}\r\n\tgetByType(k: string, type: string) {\r\n\t\t// safely 0 since a user only ever has one punishment of each type\r\n\t\treturn this.get(k)?.filter(p => p.type === type)?.[0];\r\n\t}\r\n\teach(callback: (punishment: Punishment, id: string, map: PunishmentMap) => void) {\r\n\t\tfor (const [k, punishments] of super.entries()) {\r\n\t\t\tthis.removeExpiring(punishments);\r\n\t\t\tif (punishments.length) {\r\n\t\t\t\tfor (const punishment of punishments) {\r\n\t\t\t\t\t// eslint-disable-next-line callback-return\r\n\t\t\t\t\tcallback(punishment, k, this);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.delete(k);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tdeleteOne(k: string, punishment: Punishment) {\r\n\t\tconst list = this.get(k);\r\n\t\tif (!list) return;\r\n\t\tfor (const [i, cur] of list.entries()) {\r\n\t\t\tif (punishment.type === cur.type && cur.id === punishment.id) {\r\n\t\t\t\tlist.splice(i, 1);\r\n\t\t\t\tbreak; // we don't need to run the rest of the list here\r\n\t\t\t\t// given we will only ever have one punishment of one type\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!list.length) {\r\n\t\t\tthis.delete(k);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tadd(k: string, punishment: Punishment) {\r\n\t\tlet list = this.get(k);\r\n\t\tif (!list) {\r\n\t\t\tlist = [];\r\n\t\t\tthis.set(k, list);\r\n\t\t}\r\n\t\tfor (const [i, curPunishment] of list.entries()) {\r\n\t\t\tif (punishment.type === curPunishment.type) {\r\n\t\t\t\tif (punishment.expireTime <= curPunishment.expireTime) {\r\n\t\t\t\t\tcurPunishment.reason = punishment.reason;\r\n\t\t\t\t\t// if we already have a punishment of the same type with a higher expiration date\r\n\t\t\t\t\t// we want to just update the reason and ignore it\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t\tlist.splice(i, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tlist.push(punishment);\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nclass NestedPunishmentMap extends Map<RoomID, PunishmentMap> {\r\n\tnestedSet(k1: RoomID, k2: string, value: Punishment) {\r\n\t\tif (!this.get(k1)) {\r\n\t\t\tthis.set(k1, new PunishmentMap(k1));\r\n\t\t}\r\n\t\t// guaranteed above\r\n\t\tthis.get(k1)!.add(k2, value);\r\n\t}\r\n\tnestedGet(k1: RoomID, k2: string) {\r\n\t\tconst subMap = this.get(k1);\r\n\t\tif (!subMap) return subMap;\r\n\t\tconst punishments = subMap.get(k2);\r\n\t\tif (punishments?.length) {\r\n\t\t\treturn punishments;\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\tnestedGetByType(k1: RoomID, k2: string, type: string) {\r\n\t\treturn this.nestedGet(k1, k2)?.filter(p => p.type === type)[0];\r\n\t}\r\n\tnestedHas(k1: RoomID, k2: string) {\r\n\t\treturn !!this.nestedGet(k1, k2);\r\n\t}\r\n\tnestedDelete(k1: RoomID, k2: string) {\r\n\t\tconst subMap = this.get(k1);\r\n\t\tif (!subMap) return;\r\n\t\tsubMap.delete(k2);\r\n\t\tif (!subMap.size) this.delete(k1);\r\n\t}\r\n\tnestedEach(callback: (punishment: Punishment, roomid: RoomID, userid: string) => void) {\r\n\t\tfor (const [k1, subMap] of this.entries()) {\r\n\t\t\tfor (const [k2, punishments] of subMap.entries()) {\r\n\t\t\t\tsubMap.removeExpiring(punishments);\r\n\t\t\t\tif (punishments.length) {\r\n\t\t\t\t\tfor (const punishment of punishments) {\r\n\t\t\t\t\t\t// eslint-disable-next-line callback-return\r\n\t\t\t\t\t\tcallback(punishment, k1, k2);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.nestedDelete(k1, k2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n/*********************************************************\r\n * Persistence\r\n *********************************************************/\r\n\r\nexport const Punishments = new class {\r\n\t/**\r\n\t * ips is an ip:punishment Map\r\n\t */\r\n\treadonly ips = new PunishmentMap();\r\n\t/**\r\n\t * userids is a userid:punishment Map\r\n\t */\r\n\treadonly userids = new PunishmentMap();\r\n\t/**\r\n\t * roomUserids is a roomid:userid:punishment nested Map\r\n\t */\r\n\treadonly roomUserids = new NestedPunishmentMap();\r\n\t/**\r\n\t * roomIps is a roomid:ip:punishment Map\r\n\t */\r\n\treadonly roomIps = new NestedPunishmentMap();\r\n\t/**\r\n\t * sharedIps is an ip:note Map\r\n\t */\r\n\treadonly sharedIps = new Map<string, string>();\r\n\t/**\r\n\t * AddressRange:note map. In a separate map so we iterate a massive map a lot less.\r\n\t * (AddressRange is a bit of a premature optimization, but it saves us a conversion call on some trafficked spots)\r\n\t */\r\n\tsharedRanges = new Map<AddressRange, string>();\r\n\t/**\r\n\t * sharedIpBlacklist is an ip:note Map\r\n\t */\r\n\treadonly sharedIpBlacklist = new Map<string, string>();\r\n\t/**\r\n\t * namefilterwhitelist is a whitelistedname:whitelister Map\r\n\t */\r\n\treadonly namefilterwhitelist = new Map<string, string>();\r\n\t/**\r\n\t * Connection flood table. Separate table from IP bans.\r\n\t */\r\n\treadonly cfloods = new Set<string>();\r\n\t/**\r\n\t * Participants in groupchats whose creators were banned from using groupchats.\r\n\t * Object keys are roomids of groupchats; values are Sets of user IDs.\r\n\t */\r\n\treadonly bannedGroupchatParticipants: {[k: string]: Set<ID>} = {};\r\n\t/** roomid:timestamp map */\r\n\treadonly lastGroupchatMonitorTime: {[k: string]: number} = {};\r\n\t/**\r\n\t * Map<userid that has been warned, reason they were warned for>\r\n\t */\r\n\treadonly offlineWarns: Map<ID, string> = new Map();\r\n\t/**\r\n\t * punishType is an allcaps string, for global punishments they can be\r\n\t * anything in the punishmentTypes map.\r\n\t *\r\n\t * This map can be extended with custom punishments by chat plugins.\r\n\t *\r\n\t * Keys in the map correspond to PunishInfo */\r\n\treadonly punishmentTypes = new Map<string, PunishInfo>([\r\n\t\t...(global.Punishments?.punishmentTypes || []),\r\n\t\t['LOCK', {desc: 'locked'}],\r\n\t\t['BAN', {desc: 'globally banned'}],\r\n\t\t['NAMELOCK', {desc: 'namelocked'}],\r\n\t\t['GROUPCHATBAN', {desc: 'banned from using groupchats'}],\r\n\t\t['BATTLEBAN', {desc: 'banned from battling'}],\r\n\t]);\r\n\t/**\r\n\t * For room punishments, they can be anything in the roomPunishmentTypes map.\r\n\t *\r\n\t * This map can be extended with custom punishments by chat plugins.\r\n\t *\r\n\t * Keys in the map correspond to punishTypes, values signify the way they\r\n\t * should be displayed in /alt.\r\n\t * By default, this includes:\r\n\t * - 'ROOMBAN'\r\n\t * - 'BLACKLIST'\r\n\t * - 'MUTE' (used by getRoomPunishments)\r\n\t *\r\n\t */\r\n\treadonly roomPunishmentTypes = new Map<string, PunishInfo>([\r\n\t\t// references to global.Punishments? are here because if you hotpatch punishments without hotpatching chat,\r\n\t\t// old punishment types won't be loaded into here, which might cause issues. This guards against that.\r\n\t\t...(global.Punishments?.roomPunishmentTypes || []),\r\n\t\t['ROOMBAN', {desc: 'banned', activatePunishMonitor: true}],\r\n\t\t['BLACKLIST', {desc: 'blacklisted', activatePunishMonitor: true}],\r\n\t\t['MUTE', {desc: 'muted', activatePunishMonitor: true}],\r\n\t]);\r\n\tconstructor() {\r\n\t\tsetImmediate(() => {\r\n\t\t\tvoid Punishments.loadPunishments();\r\n\t\t\tvoid Punishments.loadRoomPunishments();\r\n\t\t\tvoid Punishments.loadBanlist();\r\n\t\t\tvoid Punishments.loadSharedIps();\r\n\t\t\tvoid Punishments.loadSharedIpBlacklist();\r\n\t\t\tvoid Punishments.loadWhitelistedNames();\r\n\t\t});\r\n\t}\r\n\r\n\t// punishments.tsv is in the format:\r\n\t// punishType, userid, ips/usernames, expiration time, reason\r\n\t// room-punishments.tsv is in the format:\r\n\t// punishType, roomid:userid, ips/usernames, expiration time, reason\r\n\tasync loadPunishments() {\r\n\t\tconst data = await FS(PUNISHMENT_FILE).readIfExists();\r\n\t\tif (!data) return;\r\n\t\tfor (const row of data.split(\"\\n\")) {\r\n\t\t\tif (!row || row === '\\r') continue;\r\n\t\t\tconst [type, id, altKeys, expireTimeStr, ...reason] = row.trim().split(\"\\t\");\r\n\t\t\tconst expireTime = Number(expireTimeStr);\r\n\t\t\tif (type === \"Punishment\") continue;\r\n\t\t\tconst keys = altKeys.split(',').concat(id);\r\n\r\n\t\t\tconst punishment = {type, id, expireTime, reason: reason.join('\\t')} as Punishment;\r\n\t\t\tif (Date.now() >= expireTime) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (const key of keys) {\r\n\t\t\t\tif (!key.trim()) continue; // ignore empty ips / userids\r\n\t\t\t\tif (!USERID_REGEX.test(key)) {\r\n\t\t\t\t\tPunishments.ips.add(key, punishment);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tPunishments.userids.add(key, punishment);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tasync loadRoomPunishments() {\r\n\t\tconst data = await FS(ROOM_PUNISHMENT_FILE).readIfExists();\r\n\t\tif (!data) return;\r\n\t\tfor (const row of data.split(\"\\n\")) {\r\n\t\t\tif (!row || row === '\\r') continue;\r\n\t\t\tconst [type, id, altKeys, expireTimeStr, ...reason] = row.trim().split(\"\\t\");\r\n\t\t\tconst expireTime = Number(expireTimeStr);\r\n\t\t\tif (type === \"Punishment\") continue;\r\n\t\t\tconst [roomid, userid] = id.split(':');\r\n\t\t\tif (!userid) continue; // invalid format\r\n\t\t\tconst keys = altKeys.split(',').concat(userid);\r\n\r\n\t\t\tconst punishment = {type, id: userid, expireTime, reason: reason.join('\\t')} as Punishment;\r\n\t\t\tif (Date.now() >= expireTime) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (const key of keys) {\r\n\t\t\t\tif (!USERID_REGEX.test(key)) {\r\n\t\t\t\t\tPunishments.roomIps.nestedSet(roomid as RoomID, key, punishment);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tPunishments.roomUserids.nestedSet(roomid as RoomID, key, punishment);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tsavePunishments() {\r\n\t\tFS(PUNISHMENT_FILE).writeUpdate(() => {\r\n\t\t\tconst saveTable = Punishments.getPunishments();\r\n\t\t\tlet buf = 'Punishment\\tUser ID\\tIPs and alts\\tExpires\\tReason\\r\\n';\r\n\t\t\tfor (const [id, entry] of saveTable) {\r\n\t\t\t\tbuf += Punishments.renderEntry(entry, id);\r\n\t\t\t}\r\n\t\t\treturn buf;\r\n\t\t}, {throttle: 5000});\r\n\t}\r\n\r\n\tsaveRoomPunishments() {\r\n\t\tFS(ROOM_PUNISHMENT_FILE).writeUpdate(() => {\r\n\t\t\tconst saveTable: [string, PunishmentEntry][] = [];\r\n\t\t\tfor (const roomid of Punishments.roomIps.keys()) {\r\n\t\t\t\tfor (const [userid, punishment] of Punishments.getPunishments(roomid, true)) {\r\n\t\t\t\t\tsaveTable.push([`${roomid}:${userid}`, punishment]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet buf = 'Punishment\\tRoom ID:User ID\\tIPs and alts\\tExpires\\tReason\\r\\n';\r\n\t\t\tfor (const [id, entry] of saveTable) {\r\n\t\t\t\tbuf += Punishments.renderEntry(entry, id);\r\n\t\t\t}\r\n\t\t\treturn buf;\r\n\t\t}, {throttle: 5000});\r\n\t}\r\n\r\n\tgetEntry(entryId: string) {\r\n\t\tlet entry: PunishmentEntry | null = null;\r\n\t\tPunishments.ips.each((punishment, ip) => {\r\n\t\t\tconst {type, id, expireTime, reason, rest} = punishment;\r\n\t\t\tif (id !== entryId) return;\r\n\t\t\tif (entry) {\r\n\t\t\t\tentry.ips.push(ip);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tentry = {\r\n\t\t\t\tuserids: [],\r\n\t\t\t\tips: [ip],\r\n\t\t\t\tpunishType: type,\r\n\t\t\t\texpireTime,\r\n\t\t\t\treason,\r\n\t\t\t\trest: rest || [],\r\n\t\t\t};\r\n\t\t});\r\n\t\tPunishments.userids.each((punishment, userid) => {\r\n\t\t\tconst {type, id, expireTime, reason, rest} = punishment;\r\n\t\t\tif (id !== entryId) return;\r\n\r\n\t\t\tif (!entry) {\r\n\t\t\t\tentry = {\r\n\t\t\t\t\tuserids: [],\r\n\t\t\t\t\tips: [],\r\n\t\t\t\t\tpunishType: type,\r\n\t\t\t\t\texpireTime,\r\n\t\t\t\t\treason,\r\n\t\t\t\t\trest: rest || [],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (userid !== id) entry.userids.push(toID(userid));\r\n\t\t});\r\n\r\n\t\treturn entry;\r\n\t}\r\n\r\n\tappendPunishment(entry: PunishmentEntry, id: string, filename: string, allowNonUserIDs?: boolean) {\r\n\t\tif (!allowNonUserIDs && id.startsWith('#')) return;\r\n\t\tconst buf = Punishments.renderEntry(entry, id);\r\n\t\treturn FS(filename).append(buf);\r\n\t}\r\n\r\n\trenderEntry(entry: PunishmentEntry, id: string) {\r\n\t\tconst keys = entry.ips.concat(entry.userids).join(',');\r\n\t\tconst row = [entry.punishType, id, keys, entry.expireTime, entry.reason, ...entry.rest];\r\n\t\treturn row.join('\\t') + '\\r\\n';\r\n\t}\r\n\r\n\tasync loadBanlist() {\r\n\t\tconst data = await FS('config/ipbans.txt').readIfExists();\r\n\t\tif (!data) return;\r\n\t\tconst rangebans = [];\r\n\t\tfor (const row of data.split(\"\\n\")) {\r\n\t\t\tconst ip = row.split('#')[0].trim();\r\n\t\t\tif (!ip) continue;\r\n\t\t\tif (ip.includes('/')) {\r\n\t\t\t\trangebans.push(ip);\r\n\t\t\t} else if (!Punishments.ips.has(ip)) {\r\n\t\t\t\tPunishments.ips.add(ip, {type: 'LOCK', id: '#ipban', expireTime: Infinity, reason: ''});\r\n\t\t\t}\r\n\t\t}\r\n\t\tPunishments.checkRangeBanned = IPTools.checker(rangebans);\r\n\t}\r\n\r\n\t/**\r\n\t * sharedips.tsv is in the format:\r\n\t * IP, type (in this case always SHARED), note\r\n\t */\r\n\tasync loadSharedIps() {\r\n\t\tconst data = await FS(SHAREDIPS_FILE).readIfExists();\r\n\t\tif (!data) return;\r\n\t\tlet needsSave = false; // do we need to re-save to fix malformed data?\r\n\t\tfor (const row of data.replace('\\r', '').split(\"\\n\")) {\r\n\t\t\tif (!row) continue;\r\n\t\t\tconst [ip, type, note] = row.trim().split(\"\\t\");\r\n\t\t\tif (ip === 'IP') {\r\n\t\t\t\tcontinue; // first row\r\n\t\t\t}\r\n\t\t\tif (IPTools.ipRegex.test(note)) {\r\n\t\t\t\t// this is handling a bug where data accidentally got reversed\r\n\t\t\t\t// (into note,shared,ip format instead of ip,shared,note format)\r\n\t\t\t\tPunishments.sharedIps.set(note, ip);\r\n\t\t\t\tneedsSave = true;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (!IPTools.ipRegex.test(ip)) {\r\n\t\t\t\tconst pattern = IPTools.stringToRange(ip);\r\n\t\t\t\tif (pattern) {\r\n\t\t\t\t\tPunishments.sharedRanges.set(pattern, note);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tMonitor.adminlog(`Invalid range data in '${SHAREDIPS_FILE}': \"${row}\".`);\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (type !== 'SHARED') continue;\r\n\r\n\t\t\tPunishments.sharedIps.set(ip, note);\r\n\t\t}\r\n\t\tif (needsSave) {\r\n\t\t\tvoid Punishments.saveSharedIps();\r\n\t\t}\r\n\t}\r\n\r\n\tappendSharedIp(ip: string, note: string) {\r\n\t\tconst pattern = IPTools.stringToRange(ip);\r\n\t\tlet ipString = ip;\r\n\t\tif (pattern && pattern.minIP !== pattern.maxIP) {\r\n\t\t\tipString = IPTools.rangeToString(pattern);\r\n\t\t}\r\n\t\tconst buf = `${ipString}\\tSHARED\\t${note}\\r\\n`;\r\n\t\treturn FS(SHAREDIPS_FILE).append(buf);\r\n\t}\r\n\r\n\tsaveSharedIps() {\r\n\t\tlet buf = 'IP\\tType\\tNote\\r\\n';\r\n\t\tfor (const [ip, note] of Punishments.sharedIps) {\r\n\t\t\tbuf += `${ip}\\tSHARED\\t${note}\\r\\n`;\r\n\t\t}\r\n\t\tfor (const [range, note] of Punishments.sharedRanges) {\r\n\t\t\tbuf += `${IPTools.rangeToString(range)}\\tSHARED\\t${note}\\r\\n`;\r\n\t\t}\r\n\r\n\t\treturn FS(SHAREDIPS_FILE).write(buf);\r\n\t}\r\n\r\n\t/**\r\n\t * sharedips.tsv is in the format:\r\n\t * IP, type (in this case always SHARED), note\r\n\t */\r\n\tasync loadSharedIpBlacklist() {\r\n\t\tconst data = await FS(SHAREDIPS_BLACKLIST_FILE).readIfExists();\r\n\t\tif (!data) return;\r\n\t\tfor (const row of data.replace('\\r', '').split(\"\\n\")) {\r\n\t\t\tif (!row) continue;\r\n\t\t\tconst [ip, reason] = row.trim().split(\"\\t\");\r\n\t\t\t// it can be an ip or a range\r\n\t\t\tif (!IPTools.ipRangeRegex.test(ip)) continue;\r\n\t\t\tif (!reason) continue;\r\n\r\n\t\t\tPunishments.sharedIpBlacklist.set(ip, reason);\r\n\t\t}\r\n\t}\r\n\r\n\tappendSharedIpBlacklist(ip: string, reason: string) {\r\n\t\tconst buf = `${ip}\\t${reason}\\r\\n`;\r\n\t\treturn FS(SHAREDIPS_BLACKLIST_FILE).append(buf);\r\n\t}\r\n\r\n\tsaveSharedIpBlacklist() {\r\n\t\tlet buf = `IP\\tReason\\r\\n`;\r\n\t\tPunishments.sharedIpBlacklist.forEach((reason, ip) => {\r\n\t\t\tbuf += `${ip}\\t${reason}\\r\\n`;\r\n\t\t});\r\n\t\treturn FS(SHAREDIPS_BLACKLIST_FILE).write(buf);\r\n\t}\r\n\r\n\tasync loadWhitelistedNames() {\r\n\t\tconst data = await FS(WHITELISTED_NAMES_FILE).readIfExists();\r\n\t\tif (!data) return;\r\n\t\tconst lines = data.split('\\n');\r\n\t\tlines.shift();\r\n\t\tfor (const line of lines) {\r\n\t\t\tconst [userid, whitelister] = line.split('\\t');\r\n\t\t\tthis.namefilterwhitelist.set(toID(userid), toID(whitelister));\r\n\t\t}\r\n\t}\r\n\r\n\tappendWhitelistedName(name: string, whitelister: string) {\r\n\t\treturn FS(WHITELISTED_NAMES_FILE).append(`${toID(name)}\\t${toID(whitelister)}\\r\\n`);\r\n\t}\r\n\r\n\tsaveNameWhitelist() {\r\n\t\tlet buf = `Userid\\tWhitelister\\t\\r\\n`;\r\n\t\tPunishments.namefilterwhitelist.forEach((userid, whitelister) => {\r\n\t\t\tbuf += `${userid}\\t${whitelister}\\r\\n`;\r\n\t\t});\r\n\t\treturn FS(WHITELISTED_NAMES_FILE).write(buf);\r\n\t}\r\n\r\n\t/*********************************************************\r\n\t * Adding and removing\r\n\t *********************************************************/\r\n\r\n\tasync punish(user: User | ID, punishment: Punishment, ignoreAlts: boolean, bypassPunishmentfilter = false) {\r\n\t\tuser = Users.get(user) || user;\r\n\t\tif (typeof user === 'string') {\r\n\t\t\treturn Punishments.punishName(user, punishment);\r\n\t\t}\r\n\r\n\t\tPunishments.checkInteractions(user.getLastId(), punishment);\r\n\r\n\t\tif (!punishment.id) punishment.id = user.getLastId();\r\n\r\n\t\tconst userids = new Set<ID>();\r\n\t\tconst ips = new Set<string>();\r\n\t\tconst mobileIps = new Set<string>();\r\n\t\tconst affected = ignoreAlts ? [user] : user.getAltUsers(PUNISH_TRUSTED, true);\r\n\t\tfor (const alt of affected) {\r\n\t\t\tawait this.punishInner(alt, punishment, userids, ips, mobileIps);\r\n\t\t}\r\n\r\n\t\tconst {type, id, expireTime, reason, rest} = punishment;\r\n\t\tuserids.delete(id as ID);\r\n\t\tvoid Punishments.appendPunishment({\r\n\t\t\tuserids: [...userids],\r\n\t\t\tips: [...ips],\r\n\t\t\tpunishType: type,\r\n\t\t\texpireTime,\r\n\t\t\treason,\r\n\t\t\trest: rest || [],\r\n\t\t}, id, PUNISHMENT_FILE);\r\n\r\n\t\tif (mobileIps.size) {\r\n\t\t\tconst mobileExpireTime = Date.now() + MOBILE_PUNISHMENT_DURATIION;\r\n\t\t\tconst mobilePunishment = {type, id, expireTime: mobileExpireTime, reason, rest} as Punishment;\r\n\t\t\tfor (const mobileIp of mobileIps) {\r\n\t\t\t\tPunishments.ips.add(mobileIp, mobilePunishment);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!bypassPunishmentfilter) Chat.punishmentfilter(user, punishment);\r\n\t\treturn affected;\r\n\t}\r\n\r\n\tasync punishInner(user: User, punishment: Punishment, userids: Set<ID>, ips: Set<string>, mobileIps: Set<string>) {\r\n\t\tconst existingPunishment = Punishments.userids.getByType(user.locked || toID(user.name), punishment.type);\r\n\t\tif (existingPunishment) {\r\n\t\t\t// don't reduce the duration of an existing punishment\r\n\t\t\tif (existingPunishment.expireTime > punishment.expireTime) {\r\n\t\t\t\tpunishment.expireTime = existingPunishment.expireTime;\r\n\t\t\t}\r\n\r\n\t\t\t// don't override stronger punishment types\r\n\t\t\tconst types = ['LOCK', 'NAMELOCK', 'BAN'];\r\n\t\t\tif (types.indexOf(existingPunishment.type) > types.indexOf(punishment.type)) {\r\n\t\t\t\tpunishment.type = existingPunishment.type;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (const ip of user.ips) {\r\n\t\t\tconst {hostType} = await IPTools.lookup(ip);\r\n\t\t\tif (hostType !== 'mobile') {\r\n\t\t\t\tPunishments.ips.add(ip, punishment);\r\n\t\t\t\tips.add(ip);\r\n\t\t\t} else {\r\n\t\t\t\tmobileIps.add(ip);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst lastUserId = user.getLastId();\r\n\t\tif (!lastUserId.startsWith('guest')) {\r\n\t\t\tPunishments.userids.add(lastUserId, punishment);\r\n\t\t}\r\n\t\tif (user.locked && !user.locked.startsWith('#')) {\r\n\t\t\tPunishments.userids.add(user.locked, punishment);\r\n\t\t\tuserids.add(user.locked as ID);\r\n\t\t}\r\n\t\tif (user.autoconfirmed) {\r\n\t\t\tPunishments.userids.add(user.autoconfirmed, punishment);\r\n\t\t\tuserids.add(user.autoconfirmed);\r\n\t\t}\r\n\t\tif (user.trusted) {\r\n\t\t\tPunishments.userids.add(user.trusted, punishment);\r\n\t\t\tuserids.add(user.trusted);\r\n\t\t}\r\n\t}\r\n\r\n\tpunishName(userid: ID, punishment: Punishment) {\r\n\t\tif (!punishment.id) punishment.id = userid;\r\n\r\n\t\tconst foundKeys = Punishments.search(userid).map(([key]) => key);\r\n\t\tconst userids = new Set<ID>([userid]);\r\n\t\tconst ips = new Set<string>();\r\n\r\n\t\tPunishments.checkInteractions(userid, punishment);\r\n\r\n\t\tfor (const key of foundKeys) {\r\n\t\t\tif (key.includes('.')) {\r\n\t\t\t\tips.add(key);\r\n\t\t\t} else {\r\n\t\t\t\tuserids.add(key as ID);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const id of userids) {\r\n\t\t\tPunishments.userids.add(id, punishment);\r\n\t\t}\r\n\t\tfor (const ip of ips) {\r\n\t\t\tPunishments.ips.add(ip, punishment);\r\n\t\t}\r\n\t\tconst {type, id, expireTime, reason, rest} = punishment;\r\n\t\tconst affected = Users.findUsers([...userids], [...ips], {includeTrusted: PUNISH_TRUSTED, forPunishment: true});\r\n\t\tuserids.delete(id as ID);\r\n\t\tvoid Punishments.appendPunishment({\r\n\t\t\tuserids: [...userids],\r\n\t\t\tips: [...ips],\r\n\t\t\tpunishType: type,\r\n\t\t\texpireTime,\r\n\t\t\treason,\r\n\t\t\trest: rest || [],\r\n\t\t}, id, PUNISHMENT_FILE);\r\n\r\n\t\tChat.punishmentfilter(userid, punishment);\r\n\t\treturn affected;\r\n\t}\r\n\r\n\tunpunish(id: string, punishType: string) {\r\n\t\tid = toID(id);\r\n\t\tconst punishment = Punishments.userids.getByType(id, punishType);\r\n\t\tif (punishment) {\r\n\t\t\tid = punishment.id;\r\n\t\t}\r\n\t\t// in theory we can stop here if punishment doesn't exist, but\r\n\t\t// in case of inconsistent state, we'll try anyway\r\n\r\n\t\tlet success: false | string = false;\r\n\t\tPunishments.ips.each((cur, key) => {\r\n\t\t\tconst {type: curPunishmentType, id: curId} = cur;\r\n\t\t\tif (curId === id && curPunishmentType === punishType) {\r\n\t\t\t\tPunishments.ips.deleteOne(key, cur);\r\n\t\t\t\tsuccess = id;\r\n\t\t\t}\r\n\t\t});\r\n\t\tPunishments.userids.each((cur, key) => {\r\n\t\t\tconst {type: curPunishmentType, id: curId} = cur;\r\n\t\t\tif (curId === id && curPunishmentType === punishType) {\r\n\t\t\t\tPunishments.userids.deleteOne(key, cur);\r\n\t\t\t\tsuccess = id;\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (success) {\r\n\t\t\tPunishments.savePunishments();\r\n\t\t}\r\n\t\treturn success;\r\n\t}\r\n\r\n\troomPunish(room: Room | RoomID, user: User | ID, punishment: Punishment) {\r\n\t\tif (typeof user === 'string') {\r\n\t\t\treturn Punishments.roomPunishName(room, user, punishment);\r\n\t\t}\r\n\r\n\t\tif (!punishment.id) punishment.id = user.getLastId();\r\n\r\n\t\tPunishments.checkInteractions(punishment.id as ID, punishment, toID(room) as RoomID);\r\n\r\n\t\tconst roomid = typeof room !== 'string' ? (room as Room).roomid : room;\r\n\t\tconst userids = new Set<ID>();\r\n\t\tconst ips = new Set<string>();\r\n\t\tconst affected = user.getAltUsers(PUNISH_TRUSTED, true);\r\n\t\tfor (const curUser of affected) {\r\n\t\t\tthis.roomPunishInner(roomid, curUser, punishment, userids, ips);\r\n\t\t}\r\n\r\n\t\tconst {type, id, expireTime, reason, rest} = punishment;\r\n\t\tuserids.delete(id as ID);\r\n\t\tvoid Punishments.appendPunishment({\r\n\t\t\tuserids: [...userids],\r\n\t\t\tips: [...ips],\r\n\t\t\tpunishType: type,\r\n\t\t\texpireTime,\r\n\t\t\treason,\r\n\t\t\trest: rest || [],\r\n\t\t}, roomid + ':' + id, ROOM_PUNISHMENT_FILE);\r\n\r\n\t\tif (typeof room !== 'string') {\r\n\t\t\troom = room as Room;\r\n\t\t\tif (!(room.settings.isPrivate === true || room.settings.isPersonal)) {\r\n\t\t\t\tvoid Punishments.monitorRoomPunishments(user);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn affected;\r\n\t}\r\n\r\n\troomPunishInner(roomid: RoomID, user: User, punishment: Punishment, userids: Set<string>, ips: Set<string>) {\r\n\t\tfor (const ip of user.ips) {\r\n\t\t\tPunishments.roomIps.nestedSet(roomid, ip, punishment);\r\n\t\t\tips.add(ip);\r\n\t\t}\r\n\t\tif (!user.id.startsWith('guest')) {\r\n\t\t\tPunishments.roomUserids.nestedSet(roomid, user.id, punishment);\r\n\t\t}\r\n\t\tif (user.autoconfirmed) {\r\n\t\t\tPunishments.roomUserids.nestedSet(roomid, user.autoconfirmed, punishment);\r\n\t\t\tuserids.add(user.autoconfirmed);\r\n\t\t}\r\n\t\tif (user.trusted) {\r\n\t\t\tPunishments.roomUserids.nestedSet(roomid, user.trusted, punishment);\r\n\t\t\tuserids.add(user.trusted);\r\n\t\t}\r\n\t}\r\n\r\n\tcheckInteractions(userid: ID, punishment: Punishment, room?: RoomID) {\r\n\t\tconst punishments = Punishments.search(userid);\r\n\t\tconst results = [];\r\n\t\tconst info = Punishments[room ? 'roomInteractions' : 'interactions'][punishment.type];\r\n\t\tif (!info) return;\r\n\t\tfor (const [k, curRoom, curPunishment] of punishments) {\r\n\t\t\tif (k !== userid || (room && curRoom !== room)) continue;\r\n\t\t\tif (info.overrides.includes(curPunishment.type)) {\r\n\t\t\t\tresults.push(curPunishment);\r\n\t\t\t\tif (room) {\r\n\t\t\t\t\tPunishments.roomUnpunish(room, userid, curPunishment.type);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tPunishments.unpunish(userid, curPunishment.type);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn results;\r\n\t}\r\n\r\n\troomPunishName(room: Room | RoomID, userid: ID, punishment: Punishment) {\r\n\t\tif (!punishment.id) punishment.id = userid;\r\n\r\n\t\tconst roomid = typeof room !== 'string' ? (room as Room).roomid : room;\r\n\t\tconst foundKeys = Punishments.search(userid).map(([key]) => key);\r\n\t\tPunishments.checkInteractions(userid, punishment, roomid);\r\n\t\tconst userids = new Set<ID>([userid]);\r\n\t\tconst ips = new Set<string>();\r\n\t\tfor (const key of foundKeys) {\r\n\t\t\tif (key.includes('.')) {\r\n\t\t\t\tips.add(key);\r\n\t\t\t} else {\r\n\t\t\t\tuserids.add(key as ID);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const id of userids) {\r\n\t\t\tPunishments.roomUserids.nestedSet(roomid, id, punishment);\r\n\t\t}\r\n\t\tfor (const ip of ips) {\r\n\t\t\tPunishments.roomIps.nestedSet(roomid, ip, punishment);\r\n\t\t}\r\n\t\tconst {type, id, expireTime, reason, rest} = punishment;\r\n\t\tconst affected = Users.findUsers([...userids], [...ips], {includeTrusted: PUNISH_TRUSTED, forPunishment: true});\r\n\t\tuserids.delete(id as ID);\r\n\t\tvoid Punishments.appendPunishment({\r\n\t\t\tuserids: [...userids],\r\n\t\t\tips: [...ips],\r\n\t\t\tpunishType: type,\r\n\t\t\texpireTime,\r\n\t\t\treason,\r\n\t\t\trest: rest || [],\r\n\t\t}, roomid + ':' + id, ROOM_PUNISHMENT_FILE);\r\n\r\n\t\tif (typeof room !== 'string') {\r\n\t\t\troom = room as Room;\r\n\t\t\tif (!(room.settings.isPrivate === true || room.settings.isPersonal)) {\r\n\t\t\t\tvoid Punishments.monitorRoomPunishments(userid);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn affected;\r\n\t}\r\n\r\n\t/**\r\n\t * @param ignoreWrite skip persistent storage\r\n\t */\r\n\troomUnpunish(room: Room | RoomID, id: string, punishType: string, ignoreWrite = false) {\r\n\t\tconst roomid = typeof room !== 'string' ? (room as Room).roomid : room;\r\n\t\tid = toID(id);\r\n\t\tconst punishment = Punishments.roomUserids.nestedGetByType(roomid, id, punishType);\r\n\t\tif (punishment) {\r\n\t\t\tid = punishment.id;\r\n\t\t}\r\n\t\t// in theory we can stop here if punishment doesn't exist, but\r\n\t\t// in case of inconsistent state, we'll try anyway\r\n\r\n\t\tlet success;\r\n\t\tconst ipSubMap = Punishments.roomIps.get(roomid);\r\n\t\tif (ipSubMap) {\r\n\t\t\tfor (const [key, punishmentList] of ipSubMap) {\r\n\t\t\t\tfor (const [i, cur] of punishmentList.entries()) {\r\n\t\t\t\t\tif (cur.id === id && cur.type === punishType) {\r\n\t\t\t\t\t\tpunishmentList.splice(i, 1);\r\n\t\t\t\t\t\tsuccess = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!punishmentList.length) {\r\n\t\t\t\t\tipSubMap.delete(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst useridSubMap = Punishments.roomUserids.get(roomid);\r\n\t\tif (useridSubMap) {\r\n\t\t\tfor (const [key, punishmentList] of useridSubMap) {\r\n\t\t\t\tfor (const [i, cur] of punishmentList.entries()) {\r\n\t\t\t\t\tif (cur.id === id && cur.type === punishType) {\r\n\t\t\t\t\t\tpunishmentList.splice(i, 1);\r\n\t\t\t\t\t\tsuccess = id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!punishmentList.length) {\r\n\t\t\t\t\t\tuseridSubMap.delete(key);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (success && !ignoreWrite) {\r\n\t\t\tPunishments.saveRoomPunishments();\r\n\t\t}\r\n\t\treturn success;\r\n\t}\r\n\r\n\taddRoomPunishmentType(\r\n\t\topts: PunishInfo & {type: string} | string,\r\n\t\t// backwards compat - todo make only PunishInfo & {type: string}\r\n\t\tdesc?: string,\r\n\t\tcallback?: PunishInfo['onActivate']\r\n\t) {\r\n\t\tif (typeof opts === 'string') {\r\n\t\t\tif (!desc) throw new Error('Desc argument must be provided if type is string');\r\n\t\t\topts = {onActivate: callback, desc, type: opts};\r\n\t\t}\r\n\t\tthis.roomPunishmentTypes.set(opts.type, opts);\r\n\t\tif (!this.sortedRoomTypes.includes(opts.type)) this.sortedRoomTypes.unshift(opts.type);\r\n\t}\r\n\r\n\taddPunishmentType(\r\n\t\topts: PunishInfo & {type: string} | string,\r\n\t\t// backwards compat - todo make only PunishInfo & {type: string}\r\n\t\tdesc?: string,\r\n\t\tcallback?: PunishInfo['onActivate']\r\n\t) {\r\n\t\tif (typeof opts === 'string') {\r\n\t\t\tif (!desc) throw new Error('Desc argument must be provided if type is string');\r\n\t\t\topts = {onActivate: callback, desc, type: opts};\r\n\t\t}\r\n\t\tthis.punishmentTypes.set(opts.type, opts);\r\n\t\tif (!this.sortedTypes.includes(opts.type)) this.sortedTypes.unshift(opts.type);\r\n\t}\r\n\r\n\t/*********************************************************\r\n\t * Specific punishments\r\n\t *********************************************************/\r\n\r\n\tasync ban(\r\n\t\tuser: User | ID, expireTime: number | null, id: ID | PunishType | null, ignoreAlts: boolean, ...reason: string[]\r\n\t) {\r\n\t\tif (!expireTime) expireTime = Date.now() + GLOBALBAN_DURATION;\r\n\t\tconst punishment = {type: 'BAN', id, expireTime, reason: reason.join(' ')} as Punishment;\r\n\r\n\t\tconst affected = await Punishments.punish(user, punishment, ignoreAlts);\r\n\t\tfor (const curUser of affected) {\r\n\t\t\tcurUser.locked = punishment.id;\r\n\t\t\tcurUser.disconnectAll();\r\n\t\t}\r\n\r\n\t\treturn affected;\r\n\t}\r\n\tunban(name: string) {\r\n\t\treturn Punishments.unpunish(name, 'BAN');\r\n\t}\r\n\tasync lock(\r\n\t\tuser: User | ID,\r\n\t\texpireTime: number | null,\r\n\t\tid: ID | PunishType | null,\r\n\t\tignoreAlts: boolean,\r\n\t\treason: string,\r\n\t\tbypassPunishmentfilter = false,\r\n\t\trest?: any[]\r\n\t) {\r\n\t\tif (!expireTime) expireTime = Date.now() + LOCK_DURATION;\r\n\t\tconst punishment = {type: 'LOCK', id, expireTime, reason: reason, rest} as Punishment;\r\n\r\n\t\tconst userObject = Users.get(user);\r\n\t\t// This makes it easier for unit tests to tell if a user was locked\r\n\t\tif (userObject) userObject.locked = punishment.id;\r\n\r\n\t\tconst affected = await Punishments.punish(user, punishment, ignoreAlts, bypassPunishmentfilter);\r\n\r\n\t\tfor (const curUser of affected) {\r\n\t\t\tPunishments.checkPunishmentTime(curUser, punishment);\r\n\t\t\tcurUser.locked = punishment.id;\r\n\t\t\tcurUser.updateIdentity();\r\n\t\t}\r\n\r\n\t\treturn affected;\r\n\t}\r\n\tasync autolock(\r\n\t\tuser: User | ID,\r\n\t\troom: Room | RoomID,\r\n\t\tsource: string,\r\n\t\treason: string,\r\n\t\tmessage: string | null,\r\n\t\tweek = false,\r\n\t\tnamelock?: string\r\n\t) {\r\n\t\tif (!message) message = reason;\r\n\r\n\t\tlet punishment = `LOCK`;\r\n\t\tlet expires = null;\r\n\t\tif (week) {\r\n\t\t\texpires = Date.now() + 7 * 24 * 60 * 60 * 1000;\r\n\t\t\tpunishment = `WEEKLOCK`;\r\n\t\t}\r\n\r\n\t\tconst userid = toID(user);\r\n\t\tif (Users.get(user)?.locked) return false;\r\n\t\tconst name = typeof user === 'string' ? user : user.name;\r\n\t\tif (namelock) {\r\n\t\t\tpunishment = `NAME${punishment}`;\r\n\t\t\tawait Punishments.namelock(user, expires, toID(namelock), false, `Autonamelock: ${name}: ${reason}`);\r\n\t\t} else {\r\n\t\t\tawait Punishments.lock(user, expires, userid, false, `Autolock: ${name}: ${reason}`);\r\n\t\t}\r\n\t\tMonitor.log(`[${source}] ${punishment}ED: ${message}`);\r\n\r\n\t\tconst logEntry = {\r\n\t\t\taction: `AUTO${punishment}`,\r\n\t\t\tvisualRoomID: typeof room !== 'string' ? (room as Room).roomid : room,\r\n\t\t\tip: typeof user !== 'string' ? user.latestIp : null,\r\n\t\t\tuserid: userid,\r\n\t\t\tnote: reason,\r\n\t\t\tisGlobal: true,\r\n\t\t};\r\n\t\tif (typeof user !== 'string') logEntry.ip = user.latestIp;\r\n\r\n\t\tconst roomObject = Rooms.get(room);\r\n\t\tconst userObject = Users.get(user);\r\n\r\n\t\tif (roomObject) {\r\n\t\t\troomObject.modlog(logEntry);\r\n\t\t} else {\r\n\t\t\tRooms.global.modlog(logEntry);\r\n\t\t}\r\n\r\n\t\tif (roomObject?.battle && userObject && userObject.connections[0]) {\r\n\t\t\tChat.parse('/savereplay forpunishment', roomObject, userObject, userObject.connections[0]);\r\n\t\t}\r\n\r\n\t\tconst roomauth = Rooms.global.destroyPersonalRooms(userid);\r\n\t\tif (roomauth.length) {\r\n\t\t\tMonitor.log(`[CrisisMonitor] Autolocked user ${name} has public roomauth (${roomauth.join(', ')}), and should probably be demoted.`);\r\n\t\t}\r\n\t}\r\n\tunlock(name: string) {\r\n\t\tconst user = Users.get(name);\r\n\t\tlet id: string = toID(name);\r\n\t\tconst success: string[] = [];\r\n\t\tif (user?.locked && !user.namelocked) {\r\n\t\t\tid = user.locked;\r\n\t\t\tuser.locked = null;\r\n\t\t\tuser.namelocked = null;\r\n\t\t\tuser.destroyPunishmentTimer();\r\n\t\t\tuser.updateIdentity();\r\n\t\t\tsuccess.push(user.getLastName());\r\n\t\t}\r\n\t\tif (!id.startsWith('#')) {\r\n\t\t\tfor (const curUser of Users.users.values()) {\r\n\t\t\t\tif (curUser.locked === id) {\r\n\t\t\t\t\tcurUser.locked = null;\r\n\t\t\t\t\tcurUser.namelocked = null;\r\n\t\t\t\t\tcurUser.destroyPunishmentTimer();\r\n\t\t\t\t\tcurUser.updateIdentity();\r\n\t\t\t\t\tsuccess.push(curUser.getLastName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (['LOCK', 'YEARLOCK'].some(type => Punishments.unpunish(name, type))) {\r\n\t\t\tif (!success.length) success.push(name);\r\n\t\t}\r\n\t\tif (!success.length) return undefined;\r\n\t\tif (!success.some(v => toID(v) === id)) {\r\n\t\t\tsuccess.push(id);\r\n\t\t}\r\n\t\treturn success;\r\n\t}\r\n\t/**\r\n\t * Sets the punishment timer for a user,\r\n\t * to either MAX_PUNISHMENT_TIMER_LENGTH or the amount of time left on the punishment.\r\n\t * It also expires a punishment if the time is up.\r\n\t */\r\n\tcheckPunishmentTime(user: User, punishment: Punishment) {\r\n\t\tif (user.punishmentTimer) {\r\n\t\t\tclearTimeout(user.punishmentTimer);\r\n\t\t\tuser.punishmentTimer = null;\r\n\t\t}\r\n\r\n\t\t// Don't unlock users who have non-time-based locks such as #hostfilter\r\n\t\t// Optional chaining doesn't seem to work properly in callbacks of setTimeout\r\n\t\tif (user.locked && user.locked.startsWith('#')) return;\r\n\r\n\t\tconst {id, expireTime} = punishment;\r\n\r\n\t\tconst timeLeft = expireTime - Date.now();\r\n\t\tif (timeLeft <= 1) {\r\n\t\t\tif (user.locked === id) Punishments.unlock(user.id);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst waitTime = Math.min(timeLeft, MAX_PUNISHMENT_TIMER_LENGTH);\r\n\t\tuser.punishmentTimer = setTimeout(() => {\r\n\t\t\t// make sure we're not referencing a pre-hotpatch Punishments instance\r\n\t\t\tglobal.Punishments.checkPunishmentTime(user, punishment);\r\n\t\t}, waitTime);\r\n\t}\r\n\tasync namelock(\r\n\t\tuser: User | ID, expireTime: number | null, id: ID | PunishType | null, ignoreAlts: boolean, ...reason: string[]\r\n\t) {\r\n\t\tif (!expireTime) expireTime = Date.now() + LOCK_DURATION;\r\n\t\tconst punishment = {type: 'NAMELOCK', id, expireTime, reason: reason.join(' ')} as Punishment;\r\n\r\n\t\tconst affected = await Punishments.punish(user, punishment, ignoreAlts);\r\n\t\tfor (const curUser of affected) {\r\n\t\t\tPunishments.checkPunishmentTime(curUser, punishment);\r\n\t\t\tcurUser.locked = punishment.id;\r\n\t\t\tcurUser.namelocked = punishment.id;\r\n\t\t\tcurUser.resetName(true);\r\n\t\t\tcurUser.updateIdentity();\r\n\t\t}\r\n\r\n\t\treturn affected;\r\n\t}\r\n\tunnamelock(name: string) {\r\n\t\tconst user = Users.get(name);\r\n\t\tlet id: string = toID(name);\r\n\t\tconst success: string[] = [];\r\n\t\tif (user?.namelocked) name = user.namelocked;\r\n\r\n\t\tconst unpunished = Punishments.unpunish(name, 'NAMELOCK');\r\n\t\tif (user?.locked) {\r\n\t\t\tid = user.locked;\r\n\t\t\tuser.locked = null;\r\n\t\t\tuser.namelocked = null;\r\n\t\t\tuser.destroyPunishmentTimer();\r\n\t\t\tuser.resetName();\r\n\t\t\tsuccess.push(user.getLastName());\r\n\t\t}\r\n\t\tif (!id.startsWith('#')) {\r\n\t\t\tfor (const curUser of Users.users.values()) {\r\n\t\t\t\tif (curUser.locked === id) {\r\n\t\t\t\t\tcurUser.locked = null;\r\n\t\t\t\t\tcurUser.namelocked = null;\r\n\t\t\t\t\tcurUser.destroyPunishmentTimer();\r\n\t\t\t\t\tcurUser.resetName();\r\n\t\t\t\t\tsuccess.push(curUser.getLastName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (unpunished && !success.length) success.push(name);\r\n\t\tif (!success.length) return false;\r\n\t\tif (!success.some(v => toID(v) === id)) {\r\n\t\t\tsuccess.push(id);\r\n\t\t}\r\n\t\treturn success;\r\n\t}\r\n\tbattleban(user: User, expireTime: number | null, id: ID | null, ...reason: string[]) {\r\n\t\tif (!expireTime) expireTime = Date.now() + BATTLEBAN_DURATION;\r\n\t\tconst punishment = {type: 'BATTLEBAN', id, expireTime, reason: reason.join(' ')} as Punishment;\r\n\r\n\t\t// Handle tournaments the user was in before being battle banned\r\n\t\tfor (const games of user.games.keys()) {\r\n\t\t\tconst game = Rooms.get(games)!.getGame(Tournaments.Tournament);\r\n\t\t\tif (!game) continue; // this should never happen\r\n\t\t\tif (game.isTournamentStarted) {\r\n\t\t\t\tgame.disqualifyUser(user.id, null, null);\r\n\t\t\t} else if (!game.isTournamentStarted) {\r\n\t\t\t\tgame.removeUser(user.id);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn Punishments.punish(user, punishment, false);\r\n\t}\r\n\tunbattleban(userid: string) {\r\n\t\tconst user = Users.get(userid);\r\n\t\tif (user) {\r\n\t\t\tconst punishment = Punishments.isBattleBanned(user);\r\n\t\t\tif (punishment) userid = punishment.id;\r\n\t\t}\r\n\t\treturn Punishments.unpunish(userid, 'BATTLEBAN');\r\n\t}\r\n\tisBattleBanned(user: User) {\r\n\t\tif (!user) throw new Error(`Trying to check if a non-existent user is battlebanned.`);\r\n\r\n\t\tlet punishment = Punishments.userids.getByType(user.id, 'BATTLEBAN');\r\n\t\tif (punishment) return punishment;\r\n\r\n\t\tif (user.autoconfirmed) {\r\n\t\t\tpunishment = Punishments.userids.getByType(user.autoconfirmed, 'BATTLEBAN');\r\n\t\t\tif (punishment) return punishment;\r\n\t\t}\r\n\r\n\t\tfor (const ip of user.ips) {\r\n\t\t\tpunishment = Punishments.ips.getByType(ip, 'BATTLEBAN');\r\n\t\t\tif (punishment) {\r\n\t\t\t\tif (Punishments.isSharedIp(ip) && user.autoconfirmed) return;\r\n\t\t\t\treturn punishment;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Bans a user from using groupchats. Returns an array of roomids of the groupchat they created, if any.\r\n\t * We don't necessarily want to delete these, since we still need to warn the participants,\r\n\t * and make a modnote of the participant names, which doesn't seem appropriate for a Punishments method.\r\n\t */\r\n\tasync groupchatBan(user: User | ID, expireTime: number | null, id: ID | null, reason: string | null) {\r\n\t\tif (!expireTime) expireTime = Date.now() + GROUPCHATBAN_DURATION;\r\n\t\tconst punishment = {type: 'GROUPCHATBAN', id, expireTime, reason} as Punishment;\r\n\r\n\t\tconst groupchatsCreated = [];\r\n\t\tconst targetUser = Users.get(user);\r\n\t\tif (targetUser) {\r\n\t\t\tfor (const roomid of targetUser.inRooms || []) {\r\n\t\t\t\tconst targetRoom = Rooms.get(roomid);\r\n\t\t\t\tif (!targetRoom?.roomid.startsWith('groupchat-')) continue;\r\n\t\t\t\ttargetRoom.game?.removeBannedUser?.(targetUser);\r\n\t\t\t\ttargetUser.leaveRoom(targetRoom.roomid);\r\n\r\n\t\t\t\t// Handle groupchats that the user created\r\n\t\t\t\tif (targetRoom.auth.get(targetUser) === Users.HOST_SYMBOL) {\r\n\t\t\t\t\tgroupchatsCreated.push(targetRoom.roomid);\r\n\t\t\t\t\tPunishments.bannedGroupchatParticipants[targetRoom.roomid] = new Set(\r\n\t\t\t\t\t\t// Room#users is a UserTable where the keys are IDs,\r\n\t\t\t\t\t\t// but typed as strings so that they can be used as object keys.\r\n\t\t\t\t\t\tObject.keys(targetRoom.users).filter(u => !targetRoom.users[u].can('lock')) as ID[]\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tawait Punishments.punish(user, punishment, false);\r\n\t\treturn groupchatsCreated;\r\n\t}\r\n\r\n\tgroupchatUnban(user: User | ID) {\r\n\t\tlet userid = (typeof user === 'object' ? user.id : user);\r\n\r\n\t\tconst punishment = Punishments.isGroupchatBanned(user);\r\n\t\tif (punishment) userid = punishment.id as ID;\r\n\r\n\t\treturn Punishments.unpunish(userid, 'GROUPCHATBAN');\r\n\t}\r\n\r\n\tisGroupchatBanned(user: User | ID) {\r\n\t\tconst userid = toID(user);\r\n\t\tconst targetUser = Users.get(user);\r\n\r\n\t\tlet punishment = Punishments.userids.getByType(userid, 'GROUPCHATBAN');\r\n\t\tif (punishment) return punishment;\r\n\r\n\t\tif (targetUser?.autoconfirmed) {\r\n\t\t\tpunishment = Punishments.userids.getByType(targetUser.autoconfirmed, 'GROUPCHATBAN');\r\n\t\t\tif (punishment) return punishment;\r\n\t\t}\r\n\r\n\t\tif (targetUser && !targetUser.trusted) {\r\n\t\t\tfor (const ip of targetUser.ips) {\r\n\t\t\t\tpunishment = Punishments.ips.getByType(ip, 'GROUPCHATBAN');\r\n\t\t\t\tif (punishment) {\r\n\t\t\t\t\tif (Punishments.isSharedIp(ip) && targetUser.autoconfirmed) return;\r\n\t\t\t\t\treturn punishment;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tisTicketBanned(user: User | ID) {\r\n\t\tconst ips = [];\r\n\t\tif (typeof user === 'object') {\r\n\t\t\tips.push(...user.ips);\r\n\t\t\tips.unshift(user.latestIp);\r\n\t\t\tuser = user.id;\r\n\t\t}\r\n\t\tconst punishment = Punishments.userids.getByType(user, 'TICKETBAN');\r\n\t\tif (punishment) return punishment;\r\n\t\t// skip if the user is autoconfirmed and on a shared ip\r\n\t\t// [0] is forced to be the latestIp\r\n\t\tif (ips.some(ip => Punishments.isSharedIp(ip))) return false;\r\n\r\n\t\tfor (const ip of ips) {\r\n\t\t\tconst curPunishment = Punishments.ips.getByType(ip, 'TICKETBAN');\r\n\t\t\tif (curPunishment) return curPunishment;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Monitors a groupchat, watching in case too many users who had participated in\r\n\t * a groupchat that was deleted because its owner was groupchatbanned join.\r\n\t */\r\n\tmonitorGroupchatJoin(room: BasicRoom, newUser: User | ID) {\r\n\t\tif (Punishments.lastGroupchatMonitorTime[room.roomid] > (Date.now() - GROUPCHAT_MONITOR_INTERVAL)) return;\r\n\t\tconst newUserID = toID(newUser);\r\n\t\tfor (const [roomid, participants] of Object.entries(Punishments.bannedGroupchatParticipants)) {\r\n\t\t\tif (!participants.has(newUserID)) continue;\r\n\t\t\tlet overlap = 0;\r\n\t\t\tfor (const participant of participants) {\r\n\t\t\t\tif (participant in room.users || room.auth.has(participant)) overlap++;\r\n\t\t\t}\r\n\t\t\tif (overlap > GROUPCHAT_PARTICIPANT_OVERLAP_THRESHOLD) {\r\n\t\t\t\tlet html = `|html|[GroupchatMonitor] The groupchat \u00AB<a href=\"/${room.roomid}\">${room.roomid}</a>\u00BB `;\r\n\t\t\t\tif (Config.modloglink) html += `(<a href=\"${Config.modloglink(new Date(), room.roomid)}\">logs</a>) `;\r\n\r\n\t\t\t\thtml += `includes ${overlap} participants from forcibly deleted groupchat \u00AB<a href=\"/${roomid}\">${roomid}</a>\u00BB`;\r\n\t\t\t\tif (Config.modloglink) html += ` (<a href=\"${Config.modloglink(new Date(), roomid)}\">logs</a>)`;\r\n\t\t\t\thtml += `.`;\r\n\r\n\t\t\t\tRooms.global.notifyRooms(['staff'], html);\r\n\t\t\t\tPunishments.lastGroupchatMonitorTime[room.roomid] = Date.now();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpunishRange(\r\n\t\trange: string,\r\n\t\treason: string,\r\n\t\texpireTime?: number | null,\r\n\t\tpunishType?: string\r\n\t) {\r\n\t\tif (!expireTime) expireTime = Date.now() + RANGELOCK_DURATION;\r\n\t\tif (!punishType) punishType = 'LOCK';\r\n\t\tconst punishment = {type: punishType, id: '#rangelock', expireTime, reason} as Punishment;\r\n\t\tPunishments.ips.add(range, punishment);\r\n\r\n\t\tconst ips = [];\r\n\t\tconst parsedRange = IPTools.stringToRange(range);\r\n\t\tif (!parsedRange) throw new Error(`Invalid IP range: ${range}`);\r\n\t\tconst {minIP, maxIP} = parsedRange;\r\n\r\n\t\tfor (let ipNumber = minIP; ipNumber <= maxIP; ipNumber++) {\r\n\t\t\tips.push(IPTools.numberToIP(ipNumber)!); // range is already validated by stringToRange\r\n\t\t}\r\n\r\n\t\tvoid Punishments.appendPunishment({\r\n\t\t\tuserids: [],\r\n\t\t\tips,\r\n\t\t\tpunishType,\r\n\t\t\texpireTime,\r\n\t\t\treason,\r\n\t\t\trest: [],\r\n\t\t}, '#rangelock', PUNISHMENT_FILE, true);\r\n\t}\r\n\tbanRange(range: string, reason: string, expireTime?: number | null) {\r\n\t\tif (!expireTime) expireTime = Date.now() + RANGELOCK_DURATION;\r\n\t\tconst punishment = {type: 'BAN', id: '#rangelock', expireTime, reason} as Punishment;\r\n\t\tPunishments.ips.add(range, punishment);\r\n\t}\r\n\r\n\troomBan(room: Room, user: User, expireTime: number | null, id: string | null, ...reason: string[]) {\r\n\t\tif (!expireTime) expireTime = Date.now() + ROOMBAN_DURATION;\r\n\t\tconst punishment = {type: 'ROOMBAN', id, expireTime, reason: reason.join(' ')} as Punishment;\r\n\r\n\t\tconst affected = Punishments.roomPunish(room, user, punishment);\r\n\t\tfor (const curUser of affected) {\r\n\t\t\troom.game?.removeBannedUser?.(curUser);\r\n\t\t\tcurUser.leaveRoom(room.roomid);\r\n\t\t}\r\n\r\n\t\tif (room.subRooms) {\r\n\t\t\tfor (const subRoom of room.subRooms.values()) {\r\n\t\t\t\tfor (const curUser of affected) {\r\n\t\t\t\t\tsubRoom.game?.removeBannedUser?.(curUser);\r\n\t\t\t\t\tcurUser.leaveRoom(subRoom.roomid);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn affected;\r\n\t}\r\n\r\n\troomBlacklist(room: Room, user: User | ID, expireTime: number | null, id: ID | null, ...reason: string[]) {\r\n\t\tif (!expireTime) expireTime = Date.now() + BLACKLIST_DURATION;\r\n\t\tconst punishment = {type: 'BLACKLIST', id, expireTime, reason: reason.join(' ')} as Punishment;\r\n\r\n\t\tconst affected = Punishments.roomPunish(room, user, punishment);\r\n\r\n\t\tfor (const curUser of affected) {\r\n\t\t\t// ensure there aren't roombans so nothing gets mixed up\r\n\t\t\tPunishments.roomUnban(room, (curUser as any).id || curUser);\r\n\t\t\troom.game?.removeBannedUser?.(curUser);\r\n\t\t\tcurUser.leaveRoom(room.roomid);\r\n\t\t}\r\n\r\n\t\tif (room.subRooms) {\r\n\t\t\tfor (const subRoom of room.subRooms.values()) {\r\n\t\t\t\tfor (const curUser of affected) {\r\n\t\t\t\t\tsubRoom.game?.removeBannedUser?.(curUser);\r\n\t\t\t\t\tcurUser.leaveRoom(subRoom.roomid);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn affected;\r\n\t}\r\n\r\n\troomUnban(room: Room, userid: string) {\r\n\t\tconst user = Users.get(userid);\r\n\t\tif (user) {\r\n\t\t\tconst punishment = Punishments.isRoomBanned(user, room.roomid);\r\n\t\t\tif (punishment) userid = punishment.id;\r\n\t\t}\r\n\t\treturn Punishments.roomUnpunish(room, userid, 'ROOMBAN');\r\n\t}\r\n\r\n\t/**\r\n\t * @param ignoreWrite Flag to skip persistent storage.\r\n\t */\r\n\troomUnblacklist(room: Room, userid: string, ignoreWrite?: boolean) {\r\n\t\tconst user = Users.get(userid);\r\n\t\tif (user) {\r\n\t\t\tconst punishment = Punishments.isRoomBanned(user, room.roomid);\r\n\t\t\tif (punishment) userid = punishment.id;\r\n\t\t}\r\n\t\treturn Punishments.roomUnpunish(room, userid, 'BLACKLIST', ignoreWrite);\r\n\t}\r\n\r\n\troomUnblacklistAll(room: Room) {\r\n\t\tconst roombans = Punishments.roomUserids.get(room.roomid);\r\n\t\tif (!roombans) return false;\r\n\r\n\t\tconst unblacklisted: string[] = [];\r\n\r\n\t\troombans.each(({type}, userid) => {\r\n\t\t\tif (type === 'BLACKLIST') {\r\n\t\t\t\tPunishments.roomUnblacklist(room, userid, true);\r\n\t\t\t\tunblacklisted.push(userid);\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (unblacklisted.length === 0) return false;\r\n\t\tPunishments.saveRoomPunishments();\r\n\t\treturn unblacklisted;\r\n\t}\r\n\r\n\taddSharedIp(ip: string, note: string) {\r\n\t\tconst pattern = IPTools.stringToRange(ip);\r\n\t\tconst isRange = pattern && pattern.minIP !== pattern.maxIP;\r\n\t\tif (isRange) {\r\n\t\t\tPunishments.sharedRanges.set(pattern, note);\r\n\t\t} else {\r\n\t\t\tPunishments.sharedIps.set(ip, note);\r\n\t\t}\r\n\t\tvoid Punishments.appendSharedIp(ip, note);\r\n\r\n\t\tfor (const user of Users.users.values()) {\r\n\t\t\tconst sharedIp = user.ips.some(\r\n\t\t\t\tcurIP => (isRange ? IPTools.checkPattern([pattern], IPTools.ipToNumber(curIP)) : curIP === ip)\r\n\t\t\t);\r\n\t\t\tif (user.locked && user.locked !== user.id && sharedIp) {\r\n\t\t\t\tif (!user.autoconfirmed) {\r\n\t\t\t\t\tuser.semilocked = `#sharedip ${user.locked}` as PunishType;\r\n\t\t\t\t}\r\n\t\t\t\tuser.locked = null;\r\n\t\t\t\tuser.namelocked = null;\r\n\t\t\t\tuser.destroyPunishmentTimer();\r\n\r\n\t\t\t\tuser.updateIdentity();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tisSharedIp(ip: string) {\r\n\t\tif (this.sharedIps.has(ip)) return true;\r\n\t\tconst num = IPTools.ipToNumber(ip);\r\n\t\tfor (const range of this.sharedRanges.keys()) {\r\n\t\t\tif (IPTools.checkPattern([range], num)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveSharedIp(ip: string) {\r\n\t\tconst pattern = IPTools.stringToRange(ip);\r\n\t\tif (pattern && pattern.minIP !== pattern.maxIP) {\r\n\t\t\t// i don't _like_ this, but map.delete on an object doesn't work.\r\n\t\t\tconst isMatch = (range: AddressRange) => (\r\n\t\t\t\trange.minIP === pattern.minIP && range.maxIP === pattern.maxIP\r\n\t\t\t);\r\n\t\t\tPunishments.sharedRanges = new Map([...Punishments.sharedRanges].filter(([range]) => !isMatch(range)));\r\n\t\t} else {\r\n\t\t\tPunishments.sharedIps.delete(ip);\r\n\t\t}\r\n\t\tvoid Punishments.saveSharedIps();\r\n\t}\r\n\r\n\taddBlacklistedSharedIp(ip: string, reason: string) {\r\n\t\tvoid Punishments.appendSharedIpBlacklist(ip, reason);\r\n\t\tPunishments.sharedIpBlacklist.set(ip, reason);\r\n\t}\r\n\r\n\tremoveBlacklistedSharedIp(ip: string) {\r\n\t\tPunishments.sharedIpBlacklist.delete(ip);\r\n\t\tvoid Punishments.saveSharedIpBlacklist();\r\n\t}\r\n\r\n\twhitelistName(name: string, whitelister: string) {\r\n\t\tif (this.namefilterwhitelist.has(name)) return false;\r\n\t\tname = toID(name);\r\n\t\twhitelister = toID(whitelister);\r\n\t\tthis.namefilterwhitelist.set(name, whitelister);\r\n\t\tvoid this.appendWhitelistedName(name, whitelister);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tunwhitelistName(name: string) {\r\n\t\tname = toID(name);\r\n\t\tif (!this.namefilterwhitelist.has(name)) return false;\r\n\t\tthis.namefilterwhitelist.delete(name);\r\n\t\tvoid this.saveNameWhitelist();\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/*********************************************************\r\n\t * Checking\r\n\t *********************************************************/\r\n\r\n\t/**\r\n\t * Returns an array of [key, roomid, punishment] pairs.\r\n\t *\r\n\t * @param searchId userid or IP\r\n\t */\r\n\tsearch(searchId: string) {\r\n\t\t/** [key, roomid, punishment][] */\r\n\t\tconst results: [string, RoomID, Punishment][] = [];\r\n\t\tPunishments.ips.each((punishment, ip) => {\r\n\t\t\tconst {id} = punishment;\r\n\r\n\t\t\tif (searchId === id || searchId === ip) {\r\n\t\t\t\tresults.push([ip, '', punishment]);\r\n\t\t\t}\r\n\t\t});\r\n\t\tPunishments.userids.each((punishment, userid) => {\r\n\t\t\tconst {id} = punishment;\r\n\r\n\t\t\tif (searchId === id || searchId === userid) {\r\n\t\t\t\tresults.push([userid, '', punishment]);\r\n\t\t\t}\r\n\t\t});\r\n\t\tPunishments.roomIps.nestedEach((punishment, roomid, ip) => {\r\n\t\t\tconst {id: punishUserid} = punishment;\r\n\r\n\t\t\tif (searchId === punishUserid || searchId === ip) {\r\n\t\t\t\tresults.push([ip, roomid, punishment]);\r\n\t\t\t}\r\n\t\t});\r\n\t\tPunishments.roomUserids.nestedEach((punishment, roomid, userid) => {\r\n\t\t\tconst {id: punishUserid} = punishment;\r\n\r\n\t\t\tif (searchId === punishUserid || searchId === userid) {\r\n\t\t\t\tresults.push([userid, roomid, punishment]);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn results;\r\n\t}\r\n\r\n\tgetPunishType(name: string) {\r\n\t\tlet punishment = Punishments.userids.get(toID(name));\r\n\t\tif (punishment) return punishment[0].type;\r\n\t\tconst user = Users.get(name);\r\n\t\tif (!user) return;\r\n\t\tpunishment = Punishments.ipSearch(user.latestIp);\r\n\t\tif (punishment) return punishment[0].type;\r\n\t\treturn '';\r\n\t}\r\n\r\n\thasPunishType(name: string, types: string | string[], ip?: string) {\r\n\t\tif (typeof types === 'string') types = [types];\r\n\t\tconst byName = Punishments.userids.get(name)?.some(p => types.includes(p.type));\r\n\t\tif (!ip) return byName;\r\n\t\treturn byName || Punishments.ipSearch(ip)?.some(p => types.includes(p.type));\r\n\t}\r\n\r\n\thasRoomPunishType(room: Room | RoomID, name: string, types: string | string[]) {\r\n\t\tif (typeof types === 'string') types = [types];\r\n\t\tif (typeof (room as Room).roomid === 'string') room = (room as Room).roomid;\r\n\t\treturn Punishments.roomUserids.nestedGet(room as RoomID, name)?.some(p => types.includes(p.type));\r\n\t}\r\n\r\n\tsortedTypes = ['TICKETBAN', 'LOCK', 'NAMELOCK', 'BAN'];\r\n\tsortedRoomTypes = [...(global.Punishments?.sortedRoomTypes || []), 'ROOMBAN', 'BLACKLIST'];\r\n\tbyWeight(punishments?: Punishment[], room = false) {\r\n\t\tif (!punishments) return [];\r\n\t\treturn Utils.sortBy(\r\n\t\t\tpunishments,\r\n\t\t\tp => -(room ? this.sortedRoomTypes : this.sortedTypes).indexOf(p.type)\r\n\t\t);\r\n\t}\r\n\r\n\tinteractions: {[k: string]: {overrides: string[]}} = {\r\n\t\tNAMELOCK: {overrides: ['LOCK']},\r\n\t};\r\n\r\n\troomInteractions: {[k: string]: {overrides: string[]}} = {\r\n\t\tBLACKLIST: {overrides: ['ROOMBAN']},\r\n\t};\r\n\r\n\t/**\r\n\t * Searches for IP in Punishments.ips\r\n\t *\r\n\t * For instance, if IP is '1.2.3.4', will return the value corresponding\r\n\t * to any of the keys in table match '1.2.3.4', '1.2.3.*', '1.2.*', or '1.*'\r\n\t *\r\n\t */\r\n\tipSearch(ip: string, type?: undefined): Punishment[] | undefined;\r\n\tipSearch(ip: string, type: string): Punishment | undefined;\r\n\tipSearch(ip: string, type?: string): Punishment | Punishment[] | undefined {\r\n\t\tconst allPunishments: Punishment[] = [];\r\n\r\n\t\tlet punishment = Punishments.ips.get(ip);\r\n\t\tif (punishment) {\r\n\t\t\tif (type) return punishment.find(p => p.type === type);\r\n\t\t\tallPunishments.push(...punishment);\r\n\t\t}\r\n\t\tlet dotIndex = ip.lastIndexOf('.');\r\n\t\tfor (let i = 0; i < 4 && dotIndex > 0; i++) {\r\n\t\t\tip = ip.substr(0, dotIndex);\r\n\t\t\tpunishment = Punishments.ips.get(ip + '.*');\r\n\t\t\tif (punishment) {\r\n\t\t\t\tif (type) return punishment.find(p => p.type === type);\r\n\t\t\t\tallPunishments.push(...punishment);\r\n\t\t\t}\r\n\t\t\tdotIndex = ip.lastIndexOf('.');\r\n\t\t}\r\n\t\treturn allPunishments.length ? allPunishments : undefined;\r\n\t}\r\n\r\n\t/** Defined in Punishments.loadBanlist */\r\n\tcheckRangeBanned(ip: string) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tcheckName(user: User, userid: string, registered: boolean) {\r\n\t\tif (userid.startsWith('guest')) return;\r\n\t\tfor (const roomid of user.inRooms) {\r\n\t\t\tPunishments.checkNewNameInRoom(user, userid, roomid);\r\n\t\t}\r\n\t\tlet punishments: Punishment[] = [];\r\n\r\n\t\tconst idPunishments = Punishments.userids.get(userid);\r\n\t\tif (idPunishments) {\r\n\t\t\tpunishments = idPunishments;\r\n\t\t}\r\n\r\n\t\tconst battleban = Punishments.isBattleBanned(user);\r\n\t\tif (battleban) punishments.push(battleban);\r\n\t\tif (user.namelocked) {\r\n\t\t\tlet punishment = Punishments.userids.get(user.namelocked)?.[0];\r\n\t\t\tif (!punishment) punishment = {type: 'NAMELOCK', id: user.namelocked, expireTime: 0, reason: ''};\r\n\t\t\tpunishments.push(punishment);\r\n\t\t}\r\n\t\tif (user.locked) {\r\n\t\t\tlet punishment = Punishments.userids.get(user.locked)?.[0];\r\n\t\t\tif (!punishment) punishment = {type: 'LOCK', id: user.locked, expireTime: 0, reason: ''};\r\n\t\t\tpunishments.push(punishment);\r\n\t\t}\r\n\r\n\t\tconst ticket = Chat.pages?.help ?\r\n\t\t\t`<a href=\"view-help-request--appeal\"><button class=\"button\"><strong>Appeal your punishment</strong></button></a>` : '';\r\n\r\n\t\tif (!punishments.length) return;\r\n\t\tPunishments.byWeight(punishments);\r\n\r\n\t\tfor (const punishment of punishments) {\r\n\t\t\tconst id = punishment.type;\r\n\t\t\tconst punishmentInfo = this.punishmentTypes.get(id);\r\n\t\t\tconst punishUserid = punishment.id;\r\n\t\t\tconst reason = punishment.reason ? Utils.html`\\n\\nReason: ${punishment.reason}` : '';\r\n\t\t\tlet appeal = ``;\r\n\t\t\tif (user.permalocked && Config.appealurl) {\r\n\t\t\t\tappeal += `\\n\\nPermanent punishments can be appealed: <a href=\"${Config.appealurl}\">${Config.appealurl}</a>`;\r\n\t\t\t} else if (ticket) {\r\n\t\t\t\tappeal += `\\n\\nIf you feel you were unfairly punished or wish to otherwise appeal, you can ${ticket}.`;\r\n\t\t\t} else if (Config.appealurl) {\r\n\t\t\t\tappeal += `\\n\\nIf you wish to appeal your punishment, please use: <a href=\"${Config.appealurl}\">${Config.appealurl}</a>`;\r\n\t\t\t}\r\n\t\t\tconst bannedUnder = punishUserid !== userid ? ` because you have the same IP as banned user: ${punishUserid}` : '';\r\n\r\n\t\t\tif (id === 'BATTLEBAN') {\r\n\t\t\t\tif (punishUserid !== user.id && Punishments.isSharedIp(user.latestIp) && user.autoconfirmed) {\r\n\t\t\t\t\tPunishments.unpunish(userid, 'BATTLEBAN');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvoid Punishments.punish(user, punishment, false);\r\n\t\t\t\t\tuser.cancelReady();\r\n\t\t\t\t\tif (!Punishments.userids.getByType(userid, 'BATTLEBAN')) {\r\n\t\t\t\t\t\tconst appealLink = ticket || (Config.appealurl ? `appeal at: ${Config.appealurl}` : ``);\r\n\t\t\t\t\t\t// Prioritize popups for other global punishments\r\n\t\t\t\t\t\tuser.send(\r\n\t\t\t\t\t\t\t`|popup||html|You are banned from battling` +\r\n\t\t\t\t\t\t\t`${punishment.id !== userid ? ` because you have the same IP as banned user: ${punishUserid}` : ''}. ` +\r\n\t\t\t\t\t\t\t`Your battle ban will expire in a few days.` +\r\n\t\t\t\t\t\t\t`${punishment.reason ? Utils.html `\\n\\nReason: ${punishment.reason}` : ``}` +\r\n\t\t\t\t\t\t\t`${appealLink ? `\\n\\nOr you can ${appealLink}.` : ``}`\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tuser.notified.punishment = true;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ((id === 'LOCK' || id === 'NAMELOCK') && punishUserid !== userid && Punishments.isSharedIp(user.latestIp)) {\r\n\t\t\t\tif (!user.autoconfirmed) {\r\n\t\t\t\t\tuser.semilocked = `#sharedip ${user.locked}` as PunishType;\r\n\t\t\t\t}\r\n\t\t\t\tuser.locked = null;\r\n\t\t\t\tuser.namelocked = null;\r\n\t\t\t\tuser.destroyPunishmentTimer();\r\n\t\t\t\tuser.updateIdentity();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (id === 'BAN') {\r\n\t\t\t\tconst appealUrl = Config.banappealurl || Config.appealurl;\r\n\t\t\t\tuser.popup(\r\n\t\t\t\t\t`Your username (${user.name}) is banned${bannedUnder}. Your ban will expire in a few days.${reason}` +\r\n\t\t\t\t\t`${appealUrl ? `||||Or you can appeal at: ${appealUrl}` : ``}`\r\n\t\t\t\t);\r\n\t\t\t\tuser.notified.punishment = true;\r\n\t\t\t\tif (registered) void Punishments.punish(user, punishment, false);\r\n\t\t\t\tuser.disconnectAll();\r\n\t\t\t\treturn; // end the loop here\r\n\t\t\t}\r\n\t\t\tif (id === 'NAMELOCK' || user.namelocked) {\r\n\t\t\t\tuser.send(`|popup||html|You are namelocked and can't have a username${bannedUnder}. Your namelock will expire in a few days.${reason}${appeal}`);\r\n\t\t\t\tuser.locked = punishUserid;\r\n\t\t\t\tuser.namelocked = punishUserid;\r\n\t\t\t\tuser.resetName();\r\n\t\t\t\tuser.updateIdentity();\r\n\t\t\t} else if (id === 'LOCK') {\r\n\t\t\t\tif (punishUserid === '#hostfilter' || punishUserid === '#ipban') {\r\n\t\t\t\t\tuser.send(`|popup||html|Your IP (${user.latestIp}) is currently locked due to being a proxy. We automatically lock these connections since they are used to spam, hack, or otherwise attack our server. Disable any proxies you are using to connect to PS.\\n\\n<a href=\"view-help-request--appeal\"><button class=\"button\">Help me with a lock from a proxy</button></a>`);\r\n\t\t\t\t} else if (user.latestHostType === 'proxy' && user.locked !== user.id) {\r\n\t\t\t\t\tuser.send(`|popup||html|You are locked${bannedUnder} on the IP (${user.latestIp}), which is a proxy. We automatically lock these connections since they are used to spam, hack, or otherwise attack our server. Disable any proxies you are using to connect to PS.\\n\\n<a href=\"view-help-request--appeal\"><button class=\"button\">Help me with a lock from a proxy</button></a>`);\r\n\t\t\t\t} else if (!user.notified.lock) {\r\n\t\t\t\t\tuser.send(`|popup||html|You are locked${bannedUnder}. ${user.permalocked ? `This lock is permanent.` : `Your lock will expire in a few days.`}${reason}${appeal}`);\r\n\t\t\t\t}\r\n\t\t\t\tuser.notified.lock = true;\r\n\t\t\t\tuser.locked = punishUserid;\r\n\t\t\t\tuser.updateIdentity();\r\n\t\t\t} else if (punishmentInfo?.onActivate) {\r\n\t\t\t\tpunishmentInfo.onActivate.call(this, user, punishment, null, punishment.id === user.id);\r\n\t\t\t}\r\n\t\t\tPunishments.checkPunishmentTime(user, punishment);\r\n\t\t}\r\n\t}\r\n\r\n\tcheckIp(user: User, connection: Connection) {\r\n\t\tconst ip = connection.ip;\r\n\t\tlet punishments = Punishments.ipSearch(ip);\r\n\r\n\t\tif (!punishments && Punishments.checkRangeBanned(ip)) {\r\n\t\t\tpunishments = [{type: 'LOCK', id: '#ipban', expireTime: Infinity, reason: ''}];\r\n\t\t}\r\n\r\n\t\tif (punishments) {\r\n\t\t\tconst isSharedIP = Punishments.isSharedIp(ip);\r\n\t\t\tlet sharedAndHasPunishment = false;\r\n\t\t\tfor (const punishment of punishments) {\r\n\t\t\t\tif (isSharedIP) {\r\n\t\t\t\t\tif (!user.locked && !user.autoconfirmed) {\r\n\t\t\t\t\t\tuser.semilocked = `#sharedip ${punishment.id}` as PunishType;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsharedAndHasPunishment = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (['BAN', 'LOCK', 'NAMELOCK'].includes(punishment.type)) {\r\n\t\t\t\t\t\tuser.locked = punishment.id;\r\n\t\t\t\t\t\tif (punishment.type === 'NAMELOCK') {\r\n\t\t\t\t\t\t\tuser.namelocked = punishment.id;\r\n\t\t\t\t\t\t\tuser.resetName(true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconst info = Punishments.punishmentTypes.get(punishment.type);\r\n\t\t\t\t\t\tinfo?.onActivate?.call(this, user, punishment, null, punishment.id === user.id);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!sharedAndHasPunishment) Punishments.checkPunishmentTime(user, Punishments.byWeight(punishments)[0]);\r\n\t\t}\r\n\r\n\t\treturn IPTools.lookup(ip).then(({dnsbl, host, hostType}) => {\r\n\t\t\tuser = connection.user || user;\r\n\r\n\t\t\tif (hostType === 'proxy' && !user.trusted && !user.locked) {\r\n\t\t\t\tuser.locked = '#hostfilter';\r\n\t\t\t} else if (dnsbl && !user.autoconfirmed) {\r\n\t\t\t\tuser.semilocked = '#dnsbl';\r\n\t\t\t}\r\n\t\t\tif (host) {\r\n\t\t\t\tuser.latestHost = host;\r\n\t\t\t\tuser.latestHostType = hostType;\r\n\t\t\t}\r\n\t\t\tChat.hostfilter(host || '', user, connection, hostType);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * IP bans need to be checked separately since we don't even want to\r\n\t * make a User object if an IP is banned.\r\n\t */\r\n\tcheckIpBanned(connection: Connection) {\r\n\t\tconst ip = connection.ip;\r\n\t\tif (Punishments.cfloods.has(ip) || (Monitor.countConnection(ip) && Punishments.cfloods.add(ip))) {\r\n\t\t\tconnection.send(`|popup||modal|PS is under heavy load and cannot accommodate your connection right now.`);\r\n\t\t\treturn '#cflood';\r\n\t\t}\r\n\r\n\t\tif (Punishments.isSharedIp(ip)) return false;\r\n\r\n\t\tlet banned: false | string = false;\r\n\t\tconst punishment = Punishments.ipSearch(ip, 'BAN');\r\n\t\tif (punishment) {\r\n\t\t\tbanned = punishment.id;\r\n\t\t}\r\n\t\tif (!banned) return false;\r\n\r\n\t\tconst appealUrl = Config.banappealurl || Config.appealurl;\r\n\t\tconnection.send(\r\n\t\t\t`|popup||modal|You are banned because you have the same IP (${ip}) as banned user '${banned}'. ` +\r\n\t\t\t`Your ban will expire in a few days.` +\r\n\t\t\t`${appealUrl ? `||||Or you can appeal at: ${appealUrl}` : ``}`\r\n\t\t);\r\n\t\tMonitor.notice(`CONNECT BLOCKED - IP BANNED: ${ip} (${banned})`);\r\n\r\n\t\treturn banned;\r\n\t}\r\n\tcheckNameInRoom(user: User, roomid: RoomID): boolean {\r\n\t\tlet punishment = Punishments.roomUserids.nestedGet(roomid, user.id);\r\n\t\tif (!punishment && user.autoconfirmed) {\r\n\t\t\tpunishment = Punishments.roomUserids.nestedGet(roomid, user.autoconfirmed);\r\n\t\t}\r\n\t\tif (punishment?.some(p => p.type === 'ROOMBAN' || p.type === 'BLACKLIST')) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tconst room = Rooms.get(roomid)!;\r\n\t\tif (room.parent) {\r\n\t\t\treturn Punishments.checkNameInRoom(user, room.parent.roomid);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @param userid The name into which the user is renamed.\r\n\t */\r\n\tcheckNewNameInRoom(user: User, userid: string, roomid: RoomID): Punishment[] | null {\r\n\t\tlet punishments: Punishment[] | null = Punishments.roomUserids.nestedGet(roomid, userid) || null;\r\n\t\tif (!punishments) {\r\n\t\t\tconst room = Rooms.get(roomid)!;\r\n\t\t\tif (room.parent) {\r\n\t\t\t\tpunishments = Punishments.roomUserids.nestedGet(room.parent.roomid, userid) || null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (punishments) {\r\n\t\t\tfor (const punishment of punishments) {\r\n\t\t\t\tconst info = this.roomPunishmentTypes.get(punishment.type);\r\n\t\t\t\tif (info?.onActivate) {\r\n\t\t\t\t\tinfo.onActivate.call(this, user, punishment, Rooms.get(roomid)!, punishment.id === user.id);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (punishment.type !== 'ROOMBAN' && punishment.type !== 'BLACKLIST') return null;\r\n\t\t\t\tconst room = Rooms.get(roomid)!;\r\n\t\t\t\troom.game?.removeBannedUser?.(user);\r\n\t\t\t\tuser.leaveRoom(room.roomid);\r\n\t\t\t}\r\n\t\t\treturn punishments;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Descriptive text for the remaining time until the punishment expires, if any.\r\n\t */\r\n\tcheckLockExpiration(userid: string | null) {\r\n\t\tif (!userid) return ``;\r\n\t\tconst punishment = Punishments.userids.getByType(userid, 'LOCK');\r\n\t\tconst user = Users.get(userid);\r\n\t\tif (user?.permalocked) return ` (never expires; you are permalocked)`;\r\n\r\n\t\treturn Punishments.checkPunishmentExpiration(punishment);\r\n\t}\r\n\r\n\tcheckPunishmentExpiration(punishment: Punishment | undefined) {\r\n\t\tif (!punishment) return ``;\r\n\t\tconst expiresIn = new Date(punishment.expireTime).getTime() - Date.now();\r\n\t\tconst expiresDays = Math.round(expiresIn / 1000 / 60 / 60 / 24);\r\n\t\tlet expiresText = '';\r\n\t\tif (expiresDays >= 1) {\r\n\t\t\texpiresText = `in around ${Chat.count(expiresDays, \"days\")}`;\r\n\t\t} else {\r\n\t\t\texpiresText = `soon`;\r\n\t\t}\r\n\t\tif (expiresIn > 1) return ` (expires ${expiresText})`;\r\n\t}\r\n\r\n\tisRoomBanned(user: User, roomid: RoomID): Punishment | undefined {\r\n\t\tif (!user) throw new Error(`Trying to check if a non-existent user is room banned.`);\r\n\r\n\t\tlet punishments = Punishments.roomUserids.nestedGet(roomid, user.id);\r\n\t\tfor (const p of punishments || []) {\r\n\t\t\tif (p.type === 'ROOMBAN' || p.type === 'BLACKLIST') return p;\r\n\t\t}\r\n\r\n\t\tif (user.autoconfirmed) {\r\n\t\t\tpunishments = Punishments.roomUserids.nestedGet(roomid, user.autoconfirmed);\r\n\t\t\tfor (const p of punishments || []) {\r\n\t\t\t\tif (p.type === 'ROOMBAN' || p.type === 'BLACKLIST') return p;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!user.trusted) {\r\n\t\t\tfor (const ip of user.ips) {\r\n\t\t\t\tpunishments = Punishments.roomIps.nestedGet(roomid, ip);\r\n\t\t\t\tif (punishments) {\r\n\t\t\t\t\tfor (const punishment of punishments) {\r\n\t\t\t\t\t\tif (punishment.type === 'ROOMBAN') {\r\n\t\t\t\t\t\t\treturn punishment;\r\n\t\t\t\t\t\t} else if (punishment.type === 'BLACKLIST') {\r\n\t\t\t\t\t\t\tif (Punishments.isSharedIp(ip) && user.autoconfirmed) continue;\r\n\r\n\t\t\t\t\t\t\treturn punishment;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (const id of user.previousIDs) {\r\n\t\t\tpunishments = Punishments.roomUserids.nestedGet(roomid, id);\r\n\t\t\tfor (const p of punishments || []) {\r\n\t\t\t\tif (['ROOMBAN', 'BLACKLIST'].includes(p.type)) return p;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst room = Rooms.get(roomid);\r\n\t\tif (!room) throw new Error(`Trying to ban a user from a nonexistent room: ${roomid}`);\r\n\r\n\t\tif (room.parent) return Punishments.isRoomBanned(user, room.parent.roomid);\r\n\t}\r\n\r\n\tisGlobalBanned(user: User): Punishment | undefined {\r\n\t\tif (!user) throw new Error(`Trying to check if a non-existent user is global banned.`);\r\n\r\n\t\tconst punishment = Punishments.userids.getByType(user.id, \"BAN\") || Punishments.userids.getByType(user.id, \"FORCEBAN\");\r\n\t\tif (punishment) return punishment;\r\n\t}\r\n\r\n\tisBlacklistedSharedIp(ip: string) {\r\n\t\tconst pattern = IPTools.stringToRange(ip);\r\n\t\tif (!pattern) {\r\n\t\t\tthrow new Error(`Invalid IP address: '${ip}'`);\r\n\t\t}\r\n\t\tfor (const [blacklisted, reason] of this.sharedIpBlacklist) {\r\n\t\t\tconst range = IPTools.stringToRange(blacklisted);\r\n\t\t\tif (!range) throw new Error(\"Falsy range in sharedIpBlacklist\");\r\n\t\t\tif (IPTools.rangeIntersects(range, pattern)) return reason;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array of all room punishments associated with a user.\r\n\t *\r\n\t * options.publicOnly will make this only return public room punishments.\r\n\t * options.checkIps will also check the IP of the user for IP-based punishments.\r\n\t */\r\n\tgetRoomPunishments(user: User | string, options: Partial<{checkIps: any, publicOnly: any}> = {}) {\r\n\t\tif (!user) return [];\r\n\t\tconst userid = toID(user);\r\n\r\n\t\tconst punishments: [Room, Punishment][] = [];\r\n\r\n\t\tfor (const curRoom of Rooms.global.chatRooms) {\r\n\t\t\tif (\r\n\t\t\t\t!curRoom || curRoom.settings.isPrivate === true ||\r\n\t\t\t\t(options.publicOnly && curRoom.settings.isPersonal)\r\n\t\t\t) continue;\r\n\t\t\tlet punishment = Punishments.roomUserids.nestedGet(curRoom.roomid, userid);\r\n\t\t\tif (punishment) {\r\n\t\t\t\tfor (const p of punishment) {\r\n\t\t\t\t\tpunishments.push([curRoom, p]);\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t} else if (options?.checkIps) {\r\n\t\t\t\tif (typeof user !== 'string') {\r\n\t\t\t\t\tlet longestIPPunishment;\r\n\t\t\t\t\tfor (const ip of user.ips) {\r\n\t\t\t\t\t\tpunishment = Punishments.roomIps.nestedGet(curRoom.roomid, ip);\r\n\t\t\t\t\t\tif (punishment && (!longestIPPunishment || punishment[2] > longestIPPunishment[2])) {\r\n\t\t\t\t\t\t\tlongestIPPunishment = punishment;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (longestIPPunishment) {\r\n\t\t\t\t\t\tfor (const p of longestIPPunishment) {\r\n\t\t\t\t\t\t\tpunishments.push([curRoom, p]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (typeof user !== 'string' && curRoom.muteQueue) {\r\n\t\t\t\t// check mutes\r\n\t\t\t\tfor (const entry of curRoom.muteQueue) {\r\n\t\t\t\t\tif (userid === entry.userid ||\r\n\t\t\t\t\t\tuser.guestNum === entry.guestNum ||\r\n\t\t\t\t\t\t(user.autoconfirmed && user.autoconfirmed === entry.autoconfirmed)) {\r\n\t\t\t\t\t\tpunishments.push([curRoom, {type: 'MUTE', id: entry.userid, expireTime: entry.time, reason: ''} as Punishment]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn punishments;\r\n\t}\r\n\tgetPunishments(roomid?: RoomID, ignoreMutes?: boolean) {\r\n\t\tconst punishmentTable: [string, PunishmentEntry][] = [];\r\n\t\tif (roomid && (!Punishments.roomIps.has(roomid) || !Punishments.roomUserids.has(roomid))) return punishmentTable;\r\n\t\t// `Punishments.roomIps.get(roomid)` guaranteed to exist above\r\n\t\t(roomid ? Punishments.roomIps.get(roomid)! : Punishments.ips).each((punishment, ip) => {\r\n\t\t\tconst {type, id, expireTime, reason, rest} = punishment;\r\n\t\t\tif (id !== '#rangelock' && id.startsWith('#')) return;\r\n\t\t\tlet entry = punishmentTable.find(e => e[0] === id && e[1].punishType === type)?.[1];\r\n\r\n\t\t\tif (entry) {\r\n\t\t\t\tentry.ips.push(ip);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tentry = {\r\n\t\t\t\tuserids: [],\r\n\t\t\t\tips: [ip],\r\n\t\t\t\tpunishType: type,\r\n\t\t\t\texpireTime,\r\n\t\t\t\treason,\r\n\t\t\t\trest: rest || [],\r\n\t\t\t};\r\n\t\t\tpunishmentTable.push([id, entry]);\r\n\t\t});\r\n\t\t// `Punishments.roomIps.get(roomid)` guaranteed to exist above\r\n\t\t(roomid ? Punishments.roomUserids.get(roomid)! : Punishments.userids).each((punishment, userid) => {\r\n\t\t\tconst {type, id, expireTime, reason, rest} = punishment;\r\n\t\t\tif (id.startsWith('#')) return;\r\n\t\t\tlet entry = punishmentTable.find(([curId, cur]) => id === curId && cur.punishType === type)?.[1];\r\n\t\t\tif (!entry) {\r\n\t\t\t\tentry = {\r\n\t\t\t\t\tuserids: [],\r\n\t\t\t\t\tips: [],\r\n\t\t\t\t\tpunishType: type,\r\n\t\t\t\t\texpireTime,\r\n\t\t\t\t\treason,\r\n\t\t\t\t\trest: rest || [],\r\n\t\t\t\t};\r\n\t\t\t\tpunishmentTable.push([id, entry]);\r\n\t\t\t}\r\n\r\n\t\t\tif (userid !== id) entry.userids.push(userid as ID); // guaranteed as per above check\r\n\t\t});\r\n\t\tif (roomid && ignoreMutes !== false) {\r\n\t\t\tconst room = Rooms.get(roomid);\r\n\t\t\tif (room?.muteQueue) {\r\n\t\t\t\tfor (const mute of room.muteQueue) {\r\n\t\t\t\t\tpunishmentTable.push([mute.userid, {\r\n\t\t\t\t\t\tuserids: [], ips: [], punishType: \"MUTE\", expireTime: mute.time, reason: \"\", rest: [],\r\n\t\t\t\t\t}]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn punishmentTable;\r\n\t}\r\n\tvisualizePunishments(punishments: Map<string, PunishmentEntry>, user: User) {\r\n\t\tlet buf = \"\";\r\n\t\tbuf += `<div class=\"ladder pad\"><h2>List of active punishments:</h2>`;\r\n\t\tbuf += `<table\">`;\r\n\t\tbuf += `<tr>`;\r\n\t\tbuf += `<th>Username</th>`;\r\n\t\tbuf += `<th>Punishment type</th>`;\r\n\t\tbuf += `<th>Expire time</th>`;\r\n\t\tbuf += `<th>Reason</th>`;\r\n\t\tbuf += `<th>Alts</th>`;\r\n\t\tif (user.can('ip')) buf += `<th>IPs</th>`;\r\n\t\tbuf += `</tr>`;\r\n\t\tfor (const [userid, punishment] of punishments) {\r\n\t\t\tconst expiresIn = new Date(punishment.expireTime).getTime() - Date.now();\r\n\t\t\tif (expiresIn < 1000) continue;\r\n\t\t\tconst expireString = Chat.toDurationString(expiresIn, {precision: 1});\r\n\t\t\tbuf += `<tr>`;\r\n\t\t\tbuf += `<td>${userid}</td>`;\r\n\t\t\tbuf += `<td>${punishment.punishType}</td>`;\r\n\t\t\tbuf += `<td>${expireString}</td>`;\r\n\t\t\tbuf += `<td>${punishment.reason || ' - '}</td>`;\r\n\t\t\tbuf += `<td>${punishment.userids.join(\", \") || ' - '}</td>`;\r\n\t\t\tif (user.can('ip')) buf += `<td>${punishment.ips.join(\", \") || ' - '}</td>`;\r\n\t\t\tbuf += `</tr>`;\r\n\t\t}\r\n\t\tbuf += `</table>`;\r\n\t\tbuf += `</div>`;\r\n\t\treturn buf;\r\n\t}\r\n\t/**\r\n\t * Notifies staff if a user has three or more room punishments.\r\n\t */\r\n\tasync monitorRoomPunishments(user: User | ID) {\r\n\t\tif ((user as User).locked) return;\r\n\t\tconst userid = toID(user);\r\n\r\n\t\t/** Default to 3 if the Config option is not defined or valid */\r\n\t\tconst minPunishments = (typeof Config.monitorminpunishments === 'number' ? Config.monitorminpunishments : 3);\r\n\t\tif (!minPunishments) return;\r\n\r\n\t\tlet punishments = Punishments.getRoomPunishments(user, {checkIps: true, publicOnly: true});\r\n\t\tpunishments = punishments.filter(([room, punishment]) => (\r\n\t\t\tPunishments.roomPunishmentTypes.get(punishment.type)?.activatePunishMonitor\r\n\t\t));\r\n\r\n\t\tif (punishments.length >= minPunishments) {\r\n\t\t\tlet points = 0;\r\n\r\n\t\t\tconst punishmentText = punishments.map(([room, punishment]) => {\r\n\t\t\t\tconst {type: punishType, id: punishUserid, reason} = punishment;\r\n\t\t\t\tif (punishType in PUNISHMENT_POINT_VALUES) points += PUNISHMENT_POINT_VALUES[punishType];\r\n\t\t\t\tlet punishDesc = Punishments.roomPunishmentTypes.get(punishType)?.desc;\r\n\t\t\t\tif (!punishDesc) punishDesc = `punished`;\r\n\t\t\t\tif (punishUserid !== userid) punishDesc += ` as ${punishUserid}`;\r\n\r\n\t\t\t\t// Backwards compatibility for current punishments\r\n\t\t\t\tconst trimmedReason = reason?.trim();\r\n\t\t\t\tif (trimmedReason && !trimmedReason.startsWith('(PROOF:')) punishDesc += `: ${trimmedReason}`;\r\n\t\t\t\treturn `<<${room}>> (${punishDesc})`;\r\n\t\t\t}).join(', ');\r\n\r\n\t\t\tif (Config.punishmentautolock && points >= AUTOLOCK_POINT_THRESHOLD) {\r\n\t\t\t\tconst rooms = punishments.map(([room]) => room).join(', ');\r\n\t\t\t\tconst reason = `Autolocked for having punishments in ${punishments.length} rooms: ${rooms}`;\r\n\t\t\t\tconst message = `${(user as User).name || userid} was locked for having punishments in ${punishments.length} rooms: ${punishmentText}`;\r\n\r\n\t\t\t\tconst globalPunishments = await Rooms.Modlog.getGlobalPunishments(userid, AUTOWEEKLOCK_DAYS_TO_SEARCH);\r\n\t\t\t\t// null check in case SQLite is disabled\r\n\t\t\t\tconst isWeek = globalPunishments !== null && globalPunishments >= AUTOWEEKLOCK_THRESHOLD;\r\n\r\n\t\t\t\tvoid Punishments.autolock(user, 'staff', 'PunishmentMonitor', reason, message, isWeek);\r\n\t\t\t\tif (typeof user !== 'string') {\r\n\t\t\t\t\tuser.popup(\r\n\t\t\t\t\t\t`|modal|You've been locked for breaking the rules in multiple chatrooms.\\n\\n` +\r\n\t\t\t\t\t\t`If you feel that your lock was unjustified, you can still PM staff members (%, @, &) to discuss it${Config.appealurl ? \" or you can appeal:\\n\" + Config.appealurl : \".\"}\\n\\n` +\r\n\t\t\t\t\t\t`Your lock will expire in a few days.`\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tMonitor.log(`[PunishmentMonitor] ${(user as User).name || userid} currently has punishments in ${punishments.length} rooms: ${punishmentText}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\trenameRoom(oldID: RoomID, newID: RoomID) {\r\n\t\tfor (const table of [Punishments.roomUserids, Punishments.roomIps]) {\r\n\t\t\tconst entry = table.get(oldID);\r\n\t\t\tif (entry) {\r\n\t\t\t\ttable.set(newID, entry);\r\n\t\t\t\ttable.delete(oldID);\r\n\t\t\t}\r\n\t\t}\r\n\t\tPunishments.saveRoomPunishments();\r\n\t}\r\n\tPunishmentMap = PunishmentMap;\r\n\tNestedPunishmentMap = NestedPunishmentMap;\r\n}();\r\n"],
  "mappings": "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",
  "names": ["id"]
}
