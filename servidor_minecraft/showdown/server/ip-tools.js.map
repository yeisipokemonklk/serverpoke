{
  "version": 3,
  "sources": ["../../../server/ip-tools.ts"],
  "sourcesContent": ["/**\r\n * IP Tools\r\n * Pokemon Showdown - http://pokemonshowdown.com/\r\n *\r\n * IPTools file has various tools for IP parsing and IP-based blocking.\r\n *\r\n * These include DNSBLs: DNS-based blackhole lists, which list IPs known for\r\n * running proxies, spamming, or other abuse.\r\n *\r\n * We also maintain our own database of datacenter IP ranges (usually\r\n * proxies). These are taken from https://github.com/client9/ipcat\r\n * but include our own database as well.\r\n *\r\n * @license MIT\r\n */\r\n\r\nconst BLOCKLISTS = ['sbl.spamhaus.org', 'rbl.efnetrbl.org'];\r\nconst HOSTS_FILE = 'config/hosts.csv';\r\nconst PROXIES_FILE = 'config/proxies.csv';\r\n\r\nimport * as dns from 'dns';\r\nimport {FS, Net, Utils} from '../lib';\r\n\r\nexport interface AddressRange {\r\n\tminIP: number;\r\n\tmaxIP: number;\r\n\thost?: string;\r\n}\r\n\r\nfunction removeNohost(hostname: string) {\r\n\t// Convert from old domain.tld.type-nohost format to new domain.tld?/type format\r\n\tif (hostname?.includes('-nohost')) {\r\n\t\tconst parts = hostname.split('.');\r\n\t\tconst suffix = parts.pop();\r\n\t\treturn `${parts.join('.')}?/${suffix?.replace('-nohost', '')}`;\r\n\t}\r\n\treturn hostname;\r\n}\r\n\r\nexport const IPTools = new class {\r\n\treadonly dnsblCache = new Map<string, string | null>([\r\n\t\t['127.0.0.1', null],\r\n\t]);\r\n\r\n\treadonly connectionTestCache = new Map<string, boolean>();\r\n\r\n\treadonly ipRegex = /^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$/;\r\n\treadonly ipRangeRegex = /^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]|\\*)){0,2}\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]|\\*)$/;\r\n\treadonly hostRegex = /^.+\\..{2,}$/;\r\n\r\n\tasync lookup(ip: string) {\r\n\t\tconst [dnsbl, host] = await Promise.all([\r\n\t\t\tIPTools.queryDnsbl(ip),\r\n\t\t\tIPTools.getHost(ip),\r\n\t\t]);\r\n\t\tconst shortHost = this.shortenHost(host);\r\n\t\tconst hostType = this.getHostType(shortHost, ip);\r\n\t\treturn {dnsbl, host, shortHost, hostType};\r\n\t}\r\n\r\n\tqueryDnsblLoop(ip: string, callback: (val: string | null) => void, reversedIpDot: string, index: number) {\r\n\t\tif (index >= BLOCKLISTS.length) {\r\n\t\t\t// not in any blocklist\r\n\t\t\tIPTools.dnsblCache.set(ip, null);\r\n\t\t\tcallback(null);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst blocklist = BLOCKLISTS[index];\r\n\t\tdns.lookup(reversedIpDot + blocklist, 4, (err, res) => {\r\n\t\t\tif (!err) {\r\n\t\t\t\t// blocked\r\n\t\t\t\tIPTools.dnsblCache.set(ip, blocklist);\r\n\t\t\t\tcallback(blocklist);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// not blocked, try next blocklist\r\n\t\t\tIPTools.queryDnsblLoop(ip, callback, reversedIpDot, index + 1);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * IPTools.queryDnsbl(ip, callback)\r\n\t *\r\n\t * Calls callb\r\n\t * ack(blocklist), where blocklist is the blocklist domain\r\n\t * if the passed IP is in a blocklist, or null if the IP is not in\r\n\t * any blocklist.\r\n\t *\r\n\t * Return value matches isBlocked when treated as a boolean.\r\n\t */\r\n\tqueryDnsbl(ip: string) {\r\n\t\tif (!Config.dnsbl) return Promise.resolve(null);\r\n\t\tif (IPTools.dnsblCache.has(ip)) {\r\n\t\t\treturn Promise.resolve(IPTools.dnsblCache.get(ip) || null);\r\n\t\t}\r\n\t\tconst reversedIpDot = ip.split('.').reverse().join('.') + '.';\r\n\t\treturn new Promise<string | null>((resolve, reject) => {\r\n\t\t\tIPTools.queryDnsblLoop(ip, resolve, reversedIpDot, 0);\r\n\t\t});\r\n\t}\r\n\r\n\t/*********************************************************\r\n\t * IP parsing\r\n\t *********************************************************/\r\n\r\n\tipToNumber(ip: string) {\r\n\t\tip = ip.trim();\r\n\t\tif (ip.includes(':') && !ip.includes('.')) {\r\n\t\t\t// IPv6, which PS does not support\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (ip.startsWith('::ffff:')) ip = ip.slice(7);\r\n\t\telse if (ip.startsWith('::')) ip = ip.slice(2);\r\n\t\tlet num = 0;\r\n\t\tconst parts = ip.split('.');\r\n\t\tif (parts.length !== 4) return null;\r\n\t\tfor (const part of parts) {\r\n\t\t\tnum *= 256;\r\n\r\n\t\t\tconst partAsInt = Utils.parseExactInt(part);\r\n\t\t\tif (isNaN(partAsInt) || partAsInt < 0 || partAsInt > 255) return null;\r\n\t\t\tnum += partAsInt;\r\n\t\t}\r\n\t\treturn num;\r\n\t}\r\n\r\n\tnumberToIP(num: number) {\r\n\t\tconst ipParts: string[] = [];\r\n\t\tif (num < 0 || num >= 256 ** 4 || num !== Math.trunc(num)) return null;\r\n\t\twhile (num) {\r\n\t\t\tconst part = num % 256;\r\n\t\t\tnum = (num - part) / 256;\r\n\t\t\tipParts.unshift(part.toString());\r\n\t\t}\r\n\t\twhile (ipParts.length < 4) ipParts.unshift('0');\r\n\t\tif (ipParts.length !== 4) return null;\r\n\t\treturn ipParts.join('.');\r\n\t}\r\n\r\n\tgetCidrRange(cidr: string): AddressRange | null {\r\n\t\tif (!cidr) return null;\r\n\t\tconst index = cidr.indexOf('/');\r\n\t\tif (index <= 0) {\r\n\t\t\tconst ip = IPTools.ipToNumber(cidr);\r\n\t\t\tif (ip === null) return null;\r\n\t\t\treturn {minIP: ip, maxIP: ip};\r\n\t\t}\r\n\t\tconst low = IPTools.ipToNumber(cidr.slice(0, index));\r\n\t\tconst bits = Utils.parseExactInt(cidr.slice(index + 1));\r\n\t\t// fun fact: IPTools fails if bits <= 1 because JavaScript\r\n\t\t// does << with signed int32s.\r\n\t\tif (low === null || !bits || bits < 2 || bits > 32) return null;\r\n\t\tconst high = low + (1 << (32 - bits)) - 1;\r\n\t\treturn {minIP: low, maxIP: high};\r\n\t}\r\n\t/** Is this an IP range supported by `stringToRange`? Note that exact IPs are also valid IP ranges. */\r\n\tisValidRange(range: string): boolean {\r\n\t\treturn IPTools.stringToRange(range) !== null;\r\n\t}\r\n\tstringToRange(range: string | null): AddressRange | null {\r\n\t\tif (!range) return null;\r\n\t\tif (range.endsWith('*')) {\r\n\t\t\tconst parts = range.replace('.*', '').split('.');\r\n\t\t\tif (parts.length > 3) return null;\r\n\t\t\tconst [a, b, c] = parts;\r\n\t\t\tconst minIP = IPTools.ipToNumber(`${a || '0'}.${b || '0'}.${c || '0'}.0`);\r\n\t\t\tconst maxIP = IPTools.ipToNumber(`${a || '255'}.${b || '255'}.${c || '255'}.255`);\r\n\t\t\tif (minIP === null || maxIP === null) return null;\r\n\t\t\treturn {minIP, maxIP};\r\n\t\t}\r\n\t\tconst index = range.indexOf('-');\r\n\t\tif (index <= 0) {\r\n\t\t\tif (range.includes('/')) return IPTools.getCidrRange(range);\r\n\t\t\tconst ip = IPTools.ipToNumber(range);\r\n\t\t\tif (ip === null) return null;\r\n\r\n\t\t\treturn {maxIP: ip, minIP: ip};\r\n\t\t}\r\n\t\tconst minIP = IPTools.ipToNumber(range.slice(0, index));\r\n\t\tconst maxIP = IPTools.ipToNumber(range.slice(index + 1));\r\n\r\n\t\tif (minIP === null || maxIP === null || maxIP < minIP) return null;\r\n\t\treturn {minIP, maxIP};\r\n\t}\r\n\trangeToString(range: AddressRange, sep = '-') {\r\n\t\treturn `${this.numberToIP(range.minIP)}${sep}${this.numberToIP(range.maxIP)}`;\r\n\t}\r\n\r\n\t/******************************\r\n\t * Range management functions *\r\n\t ******************************/\r\n\r\n\tcheckPattern(patterns: AddressRange[], num: number | null) {\r\n\t\tif (num === null) return false;\r\n\t\tfor (const pattern of patterns) {\r\n\t\t\tif (num >= pattern.minIP && num <= pattern.maxIP) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a checker function for the passed IP range or array of\r\n\t * ranges. The checker function returns true if its passed IP is\r\n\t * in the range.\r\n\t */\r\n\tchecker(rangeString: string | string[]): (ip: string) => boolean {\r\n\t\tif (!rangeString?.length) return () => false;\r\n\t\tlet ranges: AddressRange[] = [];\r\n\t\tif (typeof rangeString === 'string') {\r\n\t\t\tconst rangePatterns = IPTools.stringToRange(rangeString);\r\n\t\t\tif (rangePatterns) ranges = [rangePatterns];\r\n\t\t} else {\r\n\t\t\tranges = rangeString.map(IPTools.stringToRange).filter(x => x) as AddressRange[];\r\n\t\t}\r\n\t\treturn (ip: string) => {\r\n\t\t\tconst ipNumber = IPTools.ipToNumber(ip);\r\n\t\t\treturn IPTools.checkPattern(ranges, ipNumber);\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Proxy and host management functions\r\n\t */\r\n\tranges: (AddressRange & {host: string})[] = [];\r\n\tsingleIPOpenProxies = new Set<string>();\r\n\ttorProxyIps = new Set<string>();\r\n\tproxyHosts = new Set<string>();\r\n\tresidentialHosts = new Set<string>();\r\n\tmobileHosts = new Set<string>();\r\n\tasync loadHostsAndRanges() {\r\n\t\tconst data = await FS(HOSTS_FILE).readIfExists() + await FS(PROXIES_FILE).readIfExists();\r\n\t\t// Strip carriage returns for Windows compatibility\r\n\t\tconst rows = data.split('\\n').map(row => row.replace('\\r', ''));\r\n\t\tconst ranges = [];\r\n\t\tfor (const row of rows) {\r\n\t\t\tif (!row) continue;\r\n\t\t\tlet [type, hostOrLowIP, highIP, host] = row.split(',');\r\n\t\t\tif (!hostOrLowIP) continue;\r\n\t\t\t// Handle legacy data format\r\n\t\t\thost = removeNohost(host);\r\n\t\t\thostOrLowIP = removeNohost(hostOrLowIP);\r\n\r\n\t\t\tswitch (type) {\r\n\t\t\tcase 'IP':\r\n\t\t\t\tIPTools.singleIPOpenProxies.add(hostOrLowIP);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'HOST':\r\n\t\t\t\tIPTools.proxyHosts.add(hostOrLowIP);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'RESIDENTIAL':\r\n\t\t\t\tIPTools.residentialHosts.add(hostOrLowIP);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'MOBILE':\r\n\t\t\t\tIPTools.mobileHosts.add(hostOrLowIP);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'RANGE':\r\n\t\t\t\tif (!host) continue;\r\n\r\n\t\t\t\tconst minIP = IPTools.ipToNumber(hostOrLowIP);\r\n\t\t\t\tif (minIP === null) {\r\n\t\t\t\t\tMonitor.error(`Bad IP address in host or proxy file: '${hostOrLowIP}'`);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst maxIP = IPTools.ipToNumber(highIP);\r\n\t\t\t\tif (maxIP === null) {\r\n\t\t\t\t\tMonitor.error(`Bad IP address in host or proxy file: '${highIP}'`);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst range = {host: IPTools.urlToHost(host), maxIP, minIP};\r\n\t\t\t\tif (range.maxIP < range.minIP) throw new Error(`Bad range at ${hostOrLowIP}.`);\r\n\t\t\t\tranges.push(range);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tIPTools.ranges = ranges;\r\n\t\tIPTools.sortRanges();\r\n\t}\r\n\r\n\tsaveHostsAndRanges() {\r\n\t\tlet hostsData = '';\r\n\t\tlet proxiesData = '';\r\n\t\tfor (const ip of IPTools.singleIPOpenProxies) {\r\n\t\t\tproxiesData += `IP,${ip}\\n`;\r\n\t\t}\r\n\t\tfor (const host of IPTools.proxyHosts) {\r\n\t\t\tproxiesData += `HOST,${host}\\n`;\r\n\t\t}\r\n\t\tfor (const host of IPTools.residentialHosts) {\r\n\t\t\thostsData += `RESIDENTIAL,${host}\\n`;\r\n\t\t}\r\n\t\tfor (const host of IPTools.mobileHosts) {\r\n\t\t\thostsData += `MOBILE,${host}\\n`;\r\n\t\t}\r\n\t\tIPTools.sortRanges();\r\n\t\tfor (const range of IPTools.ranges) {\r\n\t\t\tconst data = `RANGE,${IPTools.rangeToString(range, ',')}${range.host ? `,${range.host}` : ``}\\n`;\r\n\t\t\tif (range.host?.endsWith('/proxy')) {\r\n\t\t\t\tproxiesData += data;\r\n\t\t\t} else {\r\n\t\t\t\thostsData += data;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvoid FS(HOSTS_FILE).write(hostsData);\r\n\t\tvoid FS(PROXIES_FILE).write(proxiesData);\r\n\t}\r\n\r\n\taddOpenProxies(ips: string[]) {\r\n\t\tfor (const ip of ips) {\r\n\t\t\tIPTools.singleIPOpenProxies.add(ip);\r\n\t\t}\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\taddProxyHosts(hosts: string[]) {\r\n\t\tfor (const host of hosts) {\r\n\t\t\tIPTools.proxyHosts.add(host);\r\n\t\t}\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\taddMobileHosts(hosts: string[]) {\r\n\t\tfor (const host of hosts) {\r\n\t\t\tIPTools.mobileHosts.add(host);\r\n\t\t}\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\taddResidentialHosts(hosts: string[]) {\r\n\t\tfor (const host of hosts) {\r\n\t\t\tIPTools.residentialHosts.add(host);\r\n\t\t}\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\tremoveOpenProxies(ips: string[]) {\r\n\t\tfor (const ip of ips) {\r\n\t\t\tIPTools.singleIPOpenProxies.delete(ip);\r\n\t\t}\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\tremoveResidentialHosts(hosts: string[]) {\r\n\t\tfor (const host of hosts) {\r\n\t\t\tIPTools.residentialHosts.delete(host);\r\n\t\t}\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\tremoveProxyHosts(hosts: string[]) {\r\n\t\tfor (const host of hosts) {\r\n\t\t\tIPTools.proxyHosts.delete(host);\r\n\t\t}\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\tremoveMobileHosts(hosts: string[]) {\r\n\t\tfor (const host of hosts) {\r\n\t\t\tIPTools.mobileHosts.delete(host);\r\n\t\t}\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\trangeIntersects(a: AddressRange, b: AddressRange) {\r\n\t\ttry {\r\n\t\t\tthis.checkRangeConflicts(a, [b]);\r\n\t\t} catch {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tcheckRangeConflicts(insertion: AddressRange, sortedRanges: AddressRange[], widen?: boolean) {\r\n\t\tif (insertion.maxIP < insertion.minIP) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Invalid data for address range ${IPTools.rangeToString(insertion)} (${insertion.host})`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tlet iMin = 0;\r\n\t\tlet iMax = sortedRanges.length;\r\n\t\twhile (iMin < iMax) {\r\n\t\t\tconst i = Math.floor((iMax + iMin) / 2);\r\n\t\t\tif (insertion.minIP > sortedRanges[i].minIP) {\r\n\t\t\t\tiMin = i + 1;\r\n\t\t\t} else {\r\n\t\t\t\tiMax = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (iMin < sortedRanges.length) {\r\n\t\t\tconst next = sortedRanges[iMin];\r\n\t\t\tif (insertion.minIP === next.minIP && insertion.maxIP === next.maxIP) {\r\n\t\t\t\tthrow new Error(`The address range ${IPTools.rangeToString(insertion)} (${insertion.host}) already exists`);\r\n\t\t\t}\r\n\t\t\tif (insertion.minIP <= next.minIP && insertion.maxIP >= next.maxIP) {\r\n\t\t\t\tif (widen) {\r\n\t\t\t\t\tif (sortedRanges[iMin + 1]?.minIP <= insertion.maxIP) {\r\n\t\t\t\t\t\tthrow new Error(\"You can only widen one address range at a time.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn iMin;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`Too wide: ${IPTools.rangeToString(insertion)} (${insertion.host})\\n` +\r\n\t\t\t\t\t`Intersects with: ${IPTools.rangeToString(next)} (${next.host})`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif (insertion.maxIP >= next.minIP) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`Could not insert: ${IPTools.rangeToString(insertion)} ${insertion.host}\\n` +\r\n\t\t\t\t\t`Intersects with: ${IPTools.rangeToString(next)} (${next.host})`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (iMin > 0) {\r\n\t\t\tconst prev = sortedRanges[iMin - 1];\r\n\t\t\tif (insertion.minIP >= prev.minIP && insertion.maxIP <= prev.maxIP) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`Too narrow: ${IPTools.rangeToString(insertion)} (${insertion.host})\\n` +\r\n\t\t\t\t\t`Intersects with: ${IPTools.rangeToString(prev)} (${prev.host})`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tif (insertion.minIP <= prev.maxIP) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`Could not insert: ${IPTools.rangeToString(insertion)} (${insertion.host})\\n` +\r\n\t\t\t\t\t`Intersects with: ${IPTools.rangeToString(prev)} (${prev.host})`\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/*********************************************************\r\n\t * Range handling functions\r\n\t *********************************************************/\r\n\r\n\turlToHost(url: string) {\r\n\t\tif (url.startsWith('http://')) url = url.slice(7);\r\n\t\tif (url.startsWith('https://')) url = url.slice(8);\r\n\t\tif (url.startsWith('www.')) url = url.slice(4);\r\n\t\tconst slashIndex = url.indexOf('/');\r\n\t\tif (slashIndex > 0 && url[slashIndex - 1] !== '?') url = url.slice(0, slashIndex);\r\n\t\treturn url;\r\n\t}\r\n\r\n\tsortRanges() {\r\n\t\tUtils.sortBy(IPTools.ranges, range => range.minIP);\r\n\t}\r\n\r\n\tgetRange(minIP: number, maxIP: number) {\r\n\t\tfor (const range of IPTools.ranges) {\r\n\t\t\tif (range.minIP === minIP && range.maxIP === maxIP) return range;\r\n\t\t}\r\n\t}\r\n\r\n\taddRange(range: AddressRange & {host: string}) {\r\n\t\tif (IPTools.getRange(range.minIP, range.maxIP)) {\r\n\t\t\tIPTools.removeRange(range.minIP, range.maxIP);\r\n\t\t}\r\n\t\tIPTools.ranges.push(range);\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\tremoveRange(minIP: number, maxIP: number) {\r\n\t\tIPTools.ranges = IPTools.ranges.filter(dc => dc.minIP !== minIP || dc.maxIP !== maxIP);\r\n\t\treturn IPTools.saveHostsAndRanges();\r\n\t}\r\n\r\n\t/**\r\n\t * Will not reject; IPs with no RDNS entry will resolve to\r\n\t * '[byte1].[byte2]?/unknown'.\r\n\t */\r\n\tgetHost(ip: string) {\r\n\t\treturn new Promise<string>(resolve => {\r\n\t\t\tif (!ip) {\r\n\t\t\t\tresolve('');\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst ipNumber = IPTools.ipToNumber(ip);\r\n\t\t\tif (ipNumber === null) throw new Error(`Bad IP address: '${ip}'`);\r\n\t\t\tfor (const range of IPTools.ranges) {\r\n\t\t\t\tif (ipNumber >= range.minIP && ipNumber <= range.maxIP) {\r\n\t\t\t\t\tresolve(range.host);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdns.reverse(ip, (err, hosts) => {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tresolve(`${ip.split('.').slice(0, 2).join('.')}?/unknown`);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (!hosts?.[0]) {\r\n\t\t\t\t\tif (ip.startsWith('50.')) {\r\n\t\t\t\t\t\tresolve('comcast.net?/res');\r\n\t\t\t\t\t} else if (ipNumber >= telstraRange.minIP && ipNumber <= telstraRange.maxIP) {\r\n\t\t\t\t\t\tresolve(telstraRange.host);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.testConnection(ip, result => {\r\n\t\t\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t\t\tresolve(`${ip.split('.').slice(0, 2).join('.')}?/proxy`);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tresolve(`${ip.split('.').slice(0, 2).join('.')}?/unknown`);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresolve(hosts[0]);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Does this IP respond to port 80? In theory, proxies are likely to\r\n\t * respond, while residential connections are likely to reject connections.\r\n\t *\r\n\t * Callback is guaranteed to be called exactly once, within a 1000ms\r\n\t * timeout.\r\n\t */\r\n\ttestConnection(ip: string, callback: (result: boolean) => void) {\r\n\t\tconst cachedValue = this.connectionTestCache.get(ip);\r\n\t\tif (cachedValue !== undefined) {\r\n\t\t\treturn callback(cachedValue);\r\n\t\t}\r\n\r\n\t\t// Node.js's documentation does not make this easy to write. I discovered\r\n\t\t// this behavior by manual testing:\r\n\r\n\t\t// A successful connection emits 'connect', which you should react to\r\n\t\t// with socket.destroy(), which emits 'close'.\r\n\r\n\t\t// Some IPs instantly reject connections, emitting 'error' followed\r\n\t\t// immediately by 'close'.\r\n\r\n\t\t// Some IPs just never respond, leaving you to time out. Node will\r\n\t\t// emit the 'timeout' event, but not actually do anything else, leaving\r\n\t\t// you to manually use socket.destroy(), which emits 'close'\r\n\r\n\t\tlet connected = false;\r\n\t\tconst socket = require('net').createConnection({\r\n\t\t\tport: 80,\r\n\t\t\thost: ip,\r\n\t\t\ttimeout: 1000,\r\n\t\t}, () => {\r\n\t\t\tconnected = true;\r\n\t\t\tthis.connectionTestCache.set(ip, true);\r\n\t\t\tsocket.destroy();\r\n\t\t\treturn callback(true);\r\n\t\t});\r\n\t\tsocket.on('error', () => {});\r\n\t\tsocket.on('timeout', () => socket.destroy());\r\n\t\tsocket.on('close', () => {\r\n\t\t\tif (!connected) {\r\n\t\t\t\tthis.connectionTestCache.set(ip, false);\r\n\t\t\t\treturn callback(false);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tshortenHost(host: string) {\r\n\t\tif (host.split('.').pop()?.includes('/')) return host; // It has a suffix, e.g. leaseweb.com?/proxy\r\n\t\tlet dotLoc = host.lastIndexOf('.');\r\n\t\tconst tld = host.slice(dotLoc);\r\n\t\tif (tld === '.uk' || tld === '.au' || tld === '.br') dotLoc = host.lastIndexOf('.', dotLoc - 1);\r\n\t\tdotLoc = host.lastIndexOf('.', dotLoc - 1);\r\n\t\treturn host.slice(dotLoc + 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Host types:\r\n\t * - 'res' - normal residential ISP\r\n\t * - 'shared' - like res, but shared among many people: bans will have collateral damage\r\n\t * - 'mobile' - like res, but unstable IP (IP bans don't work)\r\n\t * - 'proxy' - datacenters, VPNs, proxy services, other untrustworthy sources\r\n\t *   (note that bots will usually be hosted on these)\r\n\t * - 'res?' - likely res, but host not specifically whitelisted\r\n\t * - 'unknown' - no rdns entry, treat with suspicion\r\n\t */\r\n\tgetHostType(host: string, ip: string) {\r\n\t\tif (Punishments.isSharedIp(ip)) {\r\n\t\t\treturn 'shared';\r\n\t\t}\r\n\t\tif (this.singleIPOpenProxies.has(ip) || this.torProxyIps.has(ip)) {\r\n\t\t\t// single-IP open proxies\r\n\t\t\treturn 'proxy';\r\n\t\t}\r\n\r\n\t\tif (/^he\\.net(\\?|)\\/proxy$/.test(host)) {\r\n\t\t\t// Known to only be VPN services\r\n\t\t\tif (['74.82.60.', '72.52.87.', '65.49.126.'].some(range => ip.startsWith(range))) {\r\n\t\t\t\treturn 'proxy';\r\n\t\t\t}\r\n\t\t\t// Hurricane Electric has an annoying habit of having residential\r\n\t\t\t// internet and datacenters on the same IP ranges - we get a lot of\r\n\t\t\t// legitimate users as well as spammers on VPNs from HE.\r\n\r\n\t\t\t// This splits the difference and treats it like any other unknown IP.\r\n\t\t\treturn 'unknown';\r\n\t\t}\r\n\t\t// There were previously special cases for\r\n\t\t// 'digitalocean.proxy-nohost', 'servihosting.es.proxy-nohost'\r\n\t\t// DO is commonly used to host bots; I don't know who whitelisted\r\n\t\t// servihosting but I assume for a similar reason. This isn't actually\r\n\t\t// tenable; any service that can host bots can and does also host proxies.\r\n\t\tif (this.proxyHosts.has(host) || host.endsWith('/proxy')) {\r\n\t\t\treturn 'proxy';\r\n\t\t}\r\n\t\tif (this.residentialHosts.has(host) || host.endsWith('/res')) {\r\n\t\t\treturn 'res';\r\n\t\t}\r\n\t\tif (this.mobileHosts.has(host) || host.endsWith('/mobile')) {\r\n\t\t\treturn 'mobile';\r\n\t\t}\r\n\t\tif (/^ip-[0-9]+-[0-9]+-[0-9]+\\.net$/.test(host) || /^ip-[0-9]+-[0-9]+-[0-9]+\\.eu$/.test(host)) {\r\n\t\t\t// OVH\r\n\t\t\treturn 'proxy';\r\n\t\t}\r\n\r\n\t\tif (host.endsWith('/unknown')) {\r\n\t\t\t// rdns entry doesn't exist, and IP doesn't respond to a probe on port 80\r\n\t\t\treturn 'unknown';\r\n\t\t}\r\n\r\n\t\t// rdns entry exists but is unrecognized\r\n\t\treturn 'res?';\r\n\t}\r\n\tasync updateTorRanges() {\r\n\t\ttry {\r\n\t\t\tconst raw = await Net('https://check.torproject.org/torbulkexitlist').get();\r\n\t\t\tconst torIps = raw.split('\\n');\r\n\t\t\tfor (const ip of torIps) {\r\n\t\t\t\tif (this.ipRegex.test(ip)) {\r\n\t\t\t\t\tthis.torProxyIps.add(ip);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch {}\r\n\t}\r\n};\r\n\r\nconst telstraRange: AddressRange & {host: string} = {\r\n\tminIP: IPTools.ipToNumber(\"101.160.0.0\")!,\r\n\tmaxIP: IPTools.ipToNumber(\"101.191.255.255\")!,\r\n\thost: 'telstra.net?/res',\r\n};\r\n\r\nexport default IPTools;\r\n\r\nvoid IPTools.updateTorRanges();\r\n"],
  "mappings": "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",
  "names": ["minIP", "maxIP"]
}
