{
  "version": 3,
  "sources": ["../../../../../data/mods/gen1jpn/moves.ts"],
  "sourcesContent": ["/**\r\n * The japanese version of Blizzard in Gen 1 had a 30% chance to freeze\r\n */\r\n\r\nexport const Moves: {[k: string]: ModdedMoveData} = {\r\n\tblizzard: {\r\n\t\tinherit: true,\r\n\t\tsecondary: {\r\n\t\t\tchance: 30,\r\n\t\t\tstatus: 'frz',\r\n\t\t},\r\n\t},\r\n\tsubstitute: {\r\n\t\tinherit: true,\r\n\t\tcondition: {\r\n\t\t\tonStart(target) {\r\n\t\t\t\tthis.add('-start', target, 'Substitute');\r\n\t\t\t\tthis.effectState.hp = Math.floor(target.maxhp / 4) + 1;\r\n\t\t\t\tdelete target.volatiles['partiallytrapped'];\r\n\t\t\t},\r\n\t\t\tonTryHitPriority: -1,\r\n\t\t\tonTryHit(target, source, move) {\r\n\t\t\t\tif (move.drain) {\r\n\t\t\t\t\tthis.add('-miss', source);\r\n\t\t\t\t\tthis.hint(\"In the Japanese versions of Gen 1, draining moves always miss against substitutes.\");\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\tif (move.category === 'Status') {\r\n\t\t\t\t\t// In gen 1 it only blocks:\r\n\t\t\t\t\t// poison, confusion, secondary effect confusion, stat reducing moves and Leech Seed.\r\n\t\t\t\t\tconst subBlocked = ['lockon', 'meanlook', 'mindreader', 'nightmare'];\r\n\t\t\t\t\tif ((move.status && ['psn', 'tox'].includes(move.status)) || (move.boosts && target !== source) ||\r\n\t\t\t\t\t\tmove.volatileStatus === 'confusion' || subBlocked.includes(move.id)) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (move.volatileStatus && target === source) return;\r\n\t\t\t\t// NOTE: In future generations the damage is capped to the remaining HP of the\r\n\t\t\t\t// Substitute, here we deliberately use the uncapped damage when tracking lastDamage etc.\r\n\t\t\t\t// Also, multi-hit moves must always deal the same damage as the first hit for any subsequent hits\r\n\t\t\t\tlet uncappedDamage = move.hit > 1 ? this.lastDamage : this.actions.getDamage(source, target, move);\r\n\t\t\t\tif (!uncappedDamage && uncappedDamage !== 0) return null;\r\n\t\t\t\tuncappedDamage = this.runEvent('SubDamage', target, source, move, uncappedDamage);\r\n\t\t\t\tif (!uncappedDamage && uncappedDamage !== 0) return uncappedDamage;\r\n\t\t\t\tthis.lastDamage = uncappedDamage;\r\n\t\t\t\ttarget.volatiles['substitute'].hp -= uncappedDamage > target.volatiles['substitute'].hp ?\r\n\t\t\t\t\ttarget.volatiles['substitute'].hp : uncappedDamage;\r\n\t\t\t\tif (target.volatiles['substitute'].hp <= 0) {\r\n\t\t\t\t\ttarget.removeVolatile('substitute');\r\n\t\t\t\t\ttarget.subFainted = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.add('-activate', target, 'Substitute', '[damage]');\r\n\t\t\t\t}\r\n\t\t\t\t// Drain/recoil does not happen if the substitute breaks\r\n\t\t\t\tif (target.volatiles['substitute']) {\r\n\t\t\t\t\tif (move.recoil) {\r\n\t\t\t\t\t\tthis.damage(Math.round(uncappedDamage * move.recoil[0] / move.recoil[1]), source, target, 'recoil');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (move.drain) {\r\n\t\t\t\t\t\tthis.heal(Math.ceil(uncappedDamage * move.drain[0] / move.drain[1]), source, target, 'drain');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.runEvent('AfterSubDamage', target, source, move, uncappedDamage);\r\n\t\t\t\t// Add here counter damage\r\n\t\t\t\tconst lastAttackedBy = target.getLastAttackedBy();\r\n\t\t\t\tif (!lastAttackedBy) {\r\n\t\t\t\t\ttarget.attackedBy.push({source: source, move: move.id, damage: uncappedDamage, thisTurn: true, slot: source.getSlot()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlastAttackedBy.move = move.id;\r\n\t\t\t\t\tlastAttackedBy.damage = uncappedDamage;\r\n\t\t\t\t}\r\n\t\t\t\treturn 0;\r\n\t\t\t},\r\n\t\t\tonAccuracy(accuracy, target, source, move) {\r\n\t\t\t\tif (move.id === 'swift') {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn accuracy;\r\n\t\t\t},\r\n\t\t\tonEnd(target) {\r\n\t\t\t\tthis.add('-end', target, 'Substitute');\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n\tswift: {\r\n\t\tinherit: true,\r\n\t\taccuracy: 100,\r\n\t},\r\n};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIO,MAAM,QAAuC;AAAA,EACnD,UAAU;AAAA,IACT,SAAS;AAAA,IACT,WAAW;AAAA,MACV,QAAQ;AAAA,MACR,QAAQ;AAAA,IACT;AAAA,EACD;AAAA,EACA,YAAY;AAAA,IACX,SAAS;AAAA,IACT,WAAW;AAAA,MACV,QAAQ,QAAQ;AACf,aAAK,IAAI,UAAU,QAAQ,YAAY;AACvC,aAAK,YAAY,KAAK,KAAK,MAAM,OAAO,QAAQ,CAAC,IAAI;AACrD,eAAO,OAAO,UAAU,kBAAkB;AAAA,MAC3C;AAAA,MACA,kBAAkB;AAAA,MAClB,SAAS,QAAQ,QAAQ,MAAM;AAC9B,YAAI,KAAK,OAAO;AACf,eAAK,IAAI,SAAS,MAAM;AACxB,eAAK,KAAK,oFAAoF;AAC9F,iBAAO;AAAA,QACR;AACA,YAAI,KAAK,aAAa,UAAU;AAG/B,gBAAM,aAAa,CAAC,UAAU,YAAY,cAAc,WAAW;AACnE,cAAK,KAAK,UAAU,CAAC,OAAO,KAAK,EAAE,SAAS,KAAK,MAAM,KAAO,KAAK,UAAU,WAAW,UACvF,KAAK,mBAAmB,eAAe,WAAW,SAAS,KAAK,EAAE,GAAG;AACrE,mBAAO;AAAA,UACR;AACA;AAAA,QACD;AACA,YAAI,KAAK,kBAAkB,WAAW;AAAQ;AAI9C,YAAI,iBAAiB,KAAK,MAAM,IAAI,KAAK,aAAa,KAAK,QAAQ,UAAU,QAAQ,QAAQ,IAAI;AACjG,YAAI,CAAC,kBAAkB,mBAAmB;AAAG,iBAAO;AACpD,yBAAiB,KAAK,SAAS,aAAa,QAAQ,QAAQ,MAAM,cAAc;AAChF,YAAI,CAAC,kBAAkB,mBAAmB;AAAG,iBAAO;AACpD,aAAK,aAAa;AAClB,eAAO,UAAU,YAAY,EAAE,MAAM,iBAAiB,OAAO,UAAU,YAAY,EAAE,KACpF,OAAO,UAAU,YAAY,EAAE,KAAK;AACrC,YAAI,OAAO,UAAU,YAAY,EAAE,MAAM,GAAG;AAC3C,iBAAO,eAAe,YAAY;AAClC,iBAAO,aAAa;AAAA,QACrB,OAAO;AACN,eAAK,IAAI,aAAa,QAAQ,cAAc,UAAU;AAAA,QACvD;AAEA,YAAI,OAAO,UAAU,YAAY,GAAG;AACnC,cAAI,KAAK,QAAQ;AAChB,iBAAK,OAAO,KAAK,MAAM,iBAAiB,KAAK,OAAO,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC,GAAG,QAAQ,QAAQ,QAAQ;AAAA,UACnG;AACA,cAAI,KAAK,OAAO;AACf,iBAAK,KAAK,KAAK,KAAK,iBAAiB,KAAK,MAAM,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,GAAG,QAAQ,QAAQ,OAAO;AAAA,UAC7F;AAAA,QACD;AACA,aAAK,SAAS,kBAAkB,QAAQ,QAAQ,MAAM,cAAc;AAEpE,cAAM,iBAAiB,OAAO,kBAAkB;AAChD,YAAI,CAAC,gBAAgB;AACpB,iBAAO,WAAW,KAAK,EAAC,QAAgB,MAAM,KAAK,IAAI,QAAQ,gBAAgB,UAAU,MAAM,MAAM,OAAO,QAAQ,EAAC,CAAC;AAAA,QACvH,OAAO;AACN,yBAAe,OAAO,KAAK;AAC3B,yBAAe,SAAS;AAAA,QACzB;AACA,eAAO;AAAA,MACR;AAAA,MACA,WAAW,UAAU,QAAQ,QAAQ,MAAM;AAC1C,YAAI,KAAK,OAAO,SAAS;AACxB,iBAAO;AAAA,QACR;AACA,eAAO;AAAA,MACR;AAAA,MACA,MAAM,QAAQ;AACb,aAAK,IAAI,QAAQ,QAAQ,YAAY;AAAA,MACtC;AAAA,IACD;AAAA,EACD;AAAA,EACA,OAAO;AAAA,IACN,SAAS;AAAA,IACT,UAAU;AAAA,EACX;AACD;",
  "names": []
}
